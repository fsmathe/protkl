% \iffalse
% prot package
% Copyright 2021 Markus Kurtz
%
% If called with nonLaTeX or with \install=y or as a batch file
% generate some nice files.  Otherwise produce documentation.
%<*ignore>
	{\def\x{LaTeX2e}\expandafter}%
	\ifcase0% if \install=y or \processbatchFile is defined or \fmtname=LaTeX2e
		\ifx\install y1\fi
		\expandafter\ifx\csname processbatchFile\endcsname\relax\else1\fi
		\ifx\fmtname\x\else1\fi
	\else\csname fi\endcsname% ... go on after here
%</ignore>
%<*install>
	\input docstrip.tex
	\askforoverwritefalse
	\keepsilent
	\preamble
	This is a prot file.
	\endpreamble
	\generate{
		\file{prot.ins}{\from{prot.dtx}{install}}
		\file{prot.drv}{\from{prot.dtx}{driver}}% for documentation
		\file{prot.sty}{\from{prot.dtx}{package}}
	}
	\usedir{testfiles}
	\generate{
		\file{prot.lvt}{\from{prot.dtx}{test}}
		\file{prot.lve}{\from{prot.dtx}{expect}}
	}
	\endbatchfile
%</install>
%<*ignore>
	\fi % end the \ifcase and produce documentation
%</ignore>
%<*driver>
	\documentclass{l3doc}
	% Allow to write |\cs|
	\MakeShortVerb{\|}
	% Index via codeline
	\CodelineIndex
	\RecordChanges
	\begin{document}
		\DocInput{prot.dtx}
	\end{document}
%</driver>
%
% \fi  end the \iffalse
%
% \title{prot}
% \author{Markus Kurtz}
% \maketitle
% Dieses Paket dient dem Schreiben von Protokollen. Besonders erlaubt es, über die anwesenden Personen, Abstimmungsergebnisse, Aufgaben und Resultate Buch zu führen.
% \section{Layout}
% Wird großteils an \pkg{KoMa-Script} abgegeben.
% Für vorläufige Protokolle (Paket-Option) werden Zeilennummern ausgegeben.
% Lädt \pkg{hyperref} und setzt Titel und Autorin gemäß den Angaben.
% Angaben zu Ort und Zeit der Sitzung werden ebenfalls für Titel im Dokument und in den PDF-Informationen genutzt.
% Angaben zu Ort und Zeit der nächsten Sitzung werden am Ende ausgegeben.
% Am Ende des Protokolls bzw.\@ vor dem Anhang erscheint zudem eine Signatur.
% Es kann eine Begrüßungs- und Abschiedsfloskel ausgegeben werden.
% \section{Personen}
% Zu Beginn des Protokolls werden Personen mit dem Befehl \cs{neuePerson} angelegt, was typischerweise über \env{personenliste} geschieht.
% Für jede Person legt \cs{neuePerson} basierend auf den Argumenten eine \meta{id} fest, definiert \cs{\meta{id}} als einfaches Makro, was \meta{name} zurückgibt und speichert einige Daten.
% Zu Beginn des Dokuments kann dann eine Anwesenheitsliste oder -tabelle ausgegeben werden.
% Hiefür werden die Personen innerhalb ihrer \meta{group} sortiert und mit ggf.\@ nötiger Zusatzinformation gemeinsam ausgegeben.
% Später kann dann bei Abstimmungsergebnissen automatisch die Gesamtstimmzahl ermittelt werden und etwa mit |\erg*00| ein einstimmiges Abstimmungsergebnis ausgegeben werden.
% Hierfür ist es natürlich nötig, auch speziell zu notieren, wann Stimmberechtigte Personen die Sitzung betreten und verlassen.
% \section{Ergebnisübersicht}
% Alle Ergebnisse werden in eine ausgelagerte Datei geschrieben und können wahlweise im Protokoll selbst erscheinen oder auch in einem Übersichtsdokument oder sonstwo.
% \section{Textbausteine}
% Der Freundlichkeit halber werden verschiedene Textbausteine etwa für Währungs- und Zeitangaben bereitgestellt sowie für Einschübe für Sitzungspausen oder andere Meta-Informationen.
% Auch nützlich sind die Möglichkeiten, Befehle zu erstellen, die bei erstmaliger Verwendung eine Erklärung bereitstellen.
% \StopEventually{\PrintIndex\PrintChanges}
%
% \setcounter{StandardModuleDepth}{1}
%
% \section{Implementation}
%
% Variablen und Konstanten für Person \meta{id} werden unter \texttt{\meta{g_/c_/}prot_person_/\meta{id}/_\meta{var}\meta{_typ/:signatur}} gespeichert.
% Dies erscheint mir ein plausibles Design zu sein, insbesondere unterstützt \LaTeX3 dies nativ mittels |:c|-Argumenten.
%
% Plan: Baue Prototyp, der für genau ein simples Protokoll funktioniert und ergänze dann die nötigen Features nach und nach.
%
% #Must-have-Features
% ✓ Personenverwaltung
% • Nutzer-Interface
%   • Sitzungsdaten einlesen (als Paketoptionen mit l3keys)
%   ✓ Personentabelle einlesen
%   • Sitzungsdaten anzeigen
%   • Personentabelle anzeigen
%   • \enter[]\id, \leave[]\id, \move
%   • \result
% Extra-Features
% • Super krasse Anzeige für Abkürzungen.
% • Optionen
%
% \subsection{Dateiköpfe}
%    \begin{macrocode}
%<@@=prot>
%<*test|expect>
	\input{regression-test}
	\RequirePackage{prot}
	\RequirePackage{expl3}
	\START
	\ExplSyntaxOn
	\keys_set:nn { sys } { enable-debug, check-declarations }
	\debug_on:n { check-expressions }
%<*test>
	\cs_new:Nn \@@_test:nn { \TYPE {#1} }
	\cs_new:Nn \@@_tltest:nn { \TYPE {#1} }
	\cs_new:Nn \@@_nontest:nn {#1}
%</test>
%<*expect>
	\cs_new:Nn \@@_test:nn { \TYPE {#2} }
	\cs_new:Nn \@@_tltest:nn { \TYPE { \exp_not:n {#2} } }
	\cs_new:Nn \@@_nontest:nn {#2}
%</expect>
%</test|expect>
%<*package>
	\RequirePackage{expl3}
	\ProvidesExplPackage{prot}{2021-11-26}{1.0}{A prot and Fun Package}
%    \end{macrocode}
% \subsection{Benötigte Pakete}
%    \begin{macrocode}
	\RequirePackage{xspace}
%</package>
%    \end{macrocode}
% \subsection{Sitzungsdaten}
% \begin{macro}{}
%    \begin{macrocode}
%<*package>
	\cs_new_protected:Npn \sitzungsdaten { \keys_set:nn { prot / meeting} }
	\keys_define:nn { prot / meeting } {
		, titel .tl_set:N = \l_prot_meeting_titel_tl
		, datum .tl_set:N = \l_prot_meeting_datum_tl
		, startzeit .tl_set:N = \l_prot_meeting_start_tl
		, endzeit .tl_set:N = \l_prot_meeting_end_tl
		, version .tl_set:N = \l_prot_meeting_version_tl
		, forlaeufig .meta:n = { version = #1 }
		, forlaeufig .default:n = 0
		, vorlaeufig .meta:n =  { version = #1 }
		, vorlaeufig .default:n = 1
	}

	\NewDocumentCommand \sDatum { } { \tl_use:N { \l_prot_meeting_datum_tl } \xspace }
	\NewDocumentCommand \sStart { } { \tl_use:N { \l_prot_meeting_start_tl } ~ Uhr \xspace }
	\NewDocumentCommand \sEnde { } { \tl_use:N { \l_prot_meeting_end_tl } ~ Uhr \xspace }
	\NewDocumentCommand \sVersion { } { \tl_use:N { \l_prot_meeting_version_tl } \xspace }
%</package>
%    \end{macrocode}
%    \begin{macrocode}
%<*test|expect>
	\TEST {} {
%<*test>
	\sitzungsdaten {
		, titel = Fachschaftssitzung
		, datum = 2022-01-31
		, startzeit = 12:34
		, endzeit = 23:45
		, forlaeufig
	}
	\TYPE {
		titel = \l_prot_meeting_titel_tl \NEWLINE
		datum = \l_prot_meeting_datum_tl \NEWLINE
		startzeit = \l_prot_meeting_start_tl \NEWLINE
		endzeit = \l_prot_meeting_end_tl \NEWLINE
		version = \l_prot_meeting_version_tl \NEWLINE
	}
%</test>
%<*expect>
	\TYPE {
		titel = Fachschaftssitzung \NEWLINE
		datum = 2022-01-31 \NEWLINE
		startzeit = 12:34 \NEWLINE
		endzeit = 23:45 \NEWLINE
		version = 0 \NEWLINE
	}
%</expect>
	}
%</test|expect>
%    \end{macrocode}
% \end{macro}
% \subsection{Personentabelle einlesen und ausgeben}
% \begin{environment}{persontable}
%   Liest gesamte Tabelle ein.
%    \begin{macrocode}
%<*package>
	\NewDocumentEnvironment { persontable } { b } {
		\seq_set_split:Nnn \l@@_persontable_seq \\ {#1}
		\seq_remove_all:Nn \l@@_persontable_seq { }
		\seq_map_inline:Nn \l@@_persontable_seq {
			\seq_set_split:Nnn \l@@_personrow_seq & {##1}
			\int_compare:nNnTF { \seq_count:N \l@@_personrow_seq } = 6 {
				\exp_last_unbraced:Nx \prot_newperson_frontend:nnnnnn { \@@_seq_to_tl:N \l@@_personrow_seq }
			} {
				\msg_error:nnxx { prot } { persontable / col-count }
					{ \seq_use:Nn \l@@_personrow_seq { ~\&~ } }
					{ \seq_count:N \l@@_personrow_seq }
			}
		}
	} { }
	\seq_new:N \l@@_persontable_seq
	\seq_new:N \l@@_personrow_seq
%</package>
%    \end{macrocode}
%    \begin{macrocode}
%<*test|expect>
	\TEST { persontable } {
	\cs_new_protected_nopar:Nn \@@_test_type:nnnnnn { \TYPE { #1 | #2 | #3 | #4 | #5 | #6 } }
%<*test>
	\group_begin:
		\cs_set_eq:NN \prot_newperson_frontend:nnnnnn \@@_test_type:nnnnnn
		\begin{persontable}
			a & b & c & d & e & f \\
			q & w & e & r & t & z \\
			& Anna & - &  & foo={~bar~} & ~joah~ \\
		\end{persontable}
	\group_end:
%</test>
%<*expect>
	\@@_test_type:nnnnnn { a }{ b }{ c }{ d }{ e }{ f }
	\@@_test_type:nnnnnn { q }{ w }{ e }{ r }{ t }{ z }
	\@@_test_type:nnnnnn { }{ Anna }{ - }{  }{ foo={~bar~} }{ joah }
%</expect>
	}
%</test|expect>
%    \end{macrocode}
% \end{environment}
% \begin{macro}{\anwesenheitsliste}
%   Gibt Anwesenheitsliste aus.
%   Keyvalue-liste mit Schlüsseln für die Gruppen und Gruppenname als Wert.
%    \begin{macrocode}
%<*package>
	\cs_new_protected_nopar:Nn \prot_attendancelist: {
		\begin{description}
			\l_prot_attendance_sections_tl
		\end{description}
	}
	\cs_new_protected_nopar:Nn \prot_attendancelist_item:nn {
		\seq_if_empty:cF { l_prot_attendance_section_#1_seq } {
			\seq_set_map_x:Ncn \l_tmpa_seq { l_prot_attendance_section_#1_seq } { \prot_fullname:n {##1} }
			\exp_args:Nnx \prot_attendancelist_actualitem:nn {#2} { \seq_use:Nn \l_tmpa_seq { ,~ } }
		}
	}
	\cs_new:Nn \prot_attendancelist_actualitem:nn { \item[#1] #2 }
	\cs_new_protected_nopar:Nn \prot_attendancelist_item:n { \prot_attendancelist_item:nn {#1} {#1} }
	\NewDocumentCommand \anwesenheitsliste { } { \prot_attendancelist: }
%</package>
%    \end{macrocode}
%   Some tests:
%    \begin{macrocode}
%<*test|expect>
	\BEGINTEST { \prot_attendancelist: }
		\cs_set:Npn \begin #1 { \TYPE { BEGIN {#1} } }
		\cs_set:Npn \end #1 { \TYPE { END {#1} } }
		\let\item\relax
%<*test>
		\cs_set:Nn \prot_attendancelist_actualitem:nn { \TYPE { \item[#1] #2 } }
		\cs_set:Nn \prot_fullname:n { FN ( #1 ) }
		\seq_new:c { l_prot_attendance_section_test1_seq }
		\seq_new:c { l_prot_attendance_section_test2_seq }
		\seq_set_from_clist:cn { l_prot_attendance_section_test1_seq } { Anna, Bert, Charlotte }
		\seq_set_from_clist:cn { l_prot_attendance_section_test2_seq } { Xaver, Yvonne, Zarathrustra }
		\tl_set:Nn \l_prot_attendance_sections_tl {
			\prot_attendancelist_item:n { test1 }
			\prot_attendancelist_item:nn { test2 } { XYZ }
		}
		\prot_attendancelist:
%</test>
%<*expect>
	\TYPE {
	\begin{description}\NEWLINE
		\item[test1] FN(Anna),~FN(Bert),~FN(Charlotte)\NEWLINE
		\item[XYZ] FN(Xaver),~FN(Yvonne),~FN(Zarathrustra)\NEWLINE
	\end{description}\NEWLINE
	}
%</expect>
	\ENDTEST
%</test|expect>
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\prot_fullname:n}
%   Informationen über Person.
%    \begin{macrocode}
%<*package>
	\cs_new_nopar:Nn \prot_fullname:n {
		\exp_not:v { c_prot_person_/#1/name/first_tl }
		\space \exp_not:v { c_prot_person_/#1/name/last_tl }
	}
%</package>
%    \end{macrocode}
%   Some tests:
%    \begin{macrocode}
%<*test|expect>
	\BEGINTEST { \prot_fullname:n }
%<*test>
	\cs_new_protected_nopar:Nn \@@_test_fullname:nnn {
		\tl_const:cn { c_prot_person_/#1/name/first_tl } {#2}
		\tl_const:cn { c_prot_person_/#1/name/last_tl } {#3}
		\tl_log:x { \prot_fullname:n {#1} }
	}
%</test>
%<*expect>
	\cs_new_protected_nopar:Nn \@@_test_fullname:nnn { \tl_log:n { #2 ~ #3 } }
%</expect>
	\@@_test_fullname:nnn { FN1 } { Anna } { Rot }
	\@@_test_fullname:nnn { FN2 } { Berta~Marie } { Weiß }
	\@@_test_fullname:nnn { FN3 } { Carla \undefined } { Grün-Schwarz }
	\ENDTEST
%</test|expect>
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\prot_newperson_frontend:nnnnnn}
%   Erstellt \meta{id} und \meta{name} mittels \cs{@@_set_idname_via_shorty:nnnn} und verarbeitet Angaben zur Gruppenzugehörigkeit, Anwesenheit und Zusatzinformationen.
%    \begin{macrocode}
%<*package>
	\str_new:N \l@@_id_str
	\tl_new:N \l@@_name_tl
	\cs_new_protected_nopar:Npn \prot_newperson_frontend:nnnnnn #1#2#3#4 {
		\@@_set_idname_via_shorty:nnnn {#1} {#2} {#3} {#4}
		\exp_args:NVV \prot_newperson:nnnnnn \l@@_id_str \l@@_name_tl {#2} {#3}
	}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_set_idname_via_shorty:nnnn}
%   Nimmt |id, first, last, shorty|
%   Legt basierend auf dem ersten Argument \marg{shorty} fest, wie der Name abgekürzt werden soll.
%   Dazu nutzt es \pkg{l3str} und \pkg{l3tl}.
%    \begin{macrocode}
	\cs_new_protected_nopar:Nn \@@_set_idname_via_shorty:nnnn {
		\tl_if_blank:nTF {#4} {
			\@@_set_idname:n {#2}
		} {
			\str_set:Nn \l@@_id_str {#2}
			\tl_set:Nn \l@@_name_tl {#2}
			\str_case:onF { \tl_head:w #4 {}\q_stop } {
				{=} { \tl_put_right:Nn \l@@_name_tl { ~ #3 } }
				{?} { \tl_put_right:Nx \l@@_name_tl { ~ \tl_range:nnn {#4} {2} {-1} } }
				{:} { \tl_set:Nx \l@@_name_tl { \tl_range:nnn {#4} {2} {-1} } }
				{!} { \@@_set_abbreviation:x { \tl_range:nne {#3} {1} { \tl_count:n {#4} } } }
			} {
				\@@_set_idname:n {#4}
			}
		}
		\tl_if_blank:nF {#1} { \str_set:Nn \l@@_id_str {#1} }
		\str_remove_all:Nn \l@@_id_str {~}
		\str_remove_all:Nn \l@@_id_str {-}
	}
	\cs_new_protected_nopar:Nn \@@_set_idname:n {
		\str_set:Nn \l@@_id_str {#1}
		\tl_set:Nn \l@@_name_tl {#1}
	}
	\cs_new_protected_nopar:Nn \@@_set_abbreviation:n {
		\str_put_right:Nn \l@@_id_str {#1}
		\tl_put_right:Nn \l@@_name_tl { \prot_nbsp: #1 . }
	}
	\cs_generate_variant:Nn \@@_set_abbreviation:n { x }
	\cs_new_nopar:Nn \prot_nbsp: { \penalty10000\  }
%</package>
%    \end{macrocode}
%   Some tests:
%    \begin{macrocode}
%<*test|expect>
	\TEST { \@@_set_idname_via_shorty:nnnn } {
%<*test>
	\cs_new_protected_nopar:Nn \@@_test_shorty:nnnnnn {
		\@@_set_idname_via_shorty:nnnn {#3} { #1 } { #2 } {#4}
		\TYPE { { \l@@_id_str } ~ { \l@@_name_tl } }
	}
%</test>
%<*expect>
	\cs_new_protected_nopar:Nn \@@_test_shorty:nnnnnn { \TYPE { {#5} ~ {#6} } }
%</expect>
	\cs_new_protected_nopar:Npn \@@_test_donald:nnnn { \@@_test_shorty:nnnnnn { Donald } { Knuth } }
	\@@_test_donald:nnnn {} {} { Donald } { Donald }
	\@@_test_donald:nnnn {} { = } { Donald } { Donald ~ Knuth }
	\@@_test_donald:nnnn {} { ?Duck } { Donald } { Donald ~ Duck }
	\@@_test_donald:nnnn {} { :Don } { Donald } { Don }
	\@@_test_donald:nnnn {} { ! } { DonaldK } { Donald \prot_nbsp: K. }
	\@@_test_donald:nnnn {} { !! } { DonaldKn } { Donald \prot_nbsp: Kn. }
	% The following is weird, but you asked for it :D
	\@@_test_donald:nnnn {} { !23456 } { DonaldKnuth } { Donald \prot_nbsp: Knuth. }
	\@@_test_donald:nnnn {} { Don } { Don } { Don }
	\@@_test_donald:nnnn { DK } { Don } { DK } { Don }
	\cs_new_protected_nopar:Npn \@@_test_anna:nnnn { \@@_test_shorty:nnnnnn { Anna-Lena } { Rot ~ Grau-Schwarz } }
	\@@_test_anna:nnnn {} {} { AnnaLena } { Anna-Lena }
	\@@_test_anna:nnnn {} { !!! } { AnnaLenaRot } { Anna-Lena \prot_nbsp: Rot . }
	\@@_test_anna:nnnn {} { !!!! } { AnnaLenaRotG } { Anna-Lena \prot_nbsp: Rot ~ G . }
	\@@_test_anna:nnnn {} { !otGrau- } { AnnaLenaRotGrau } { Anna-Lena \prot_nbsp: Rot ~ Grau- . }
	\@@_test_anna:nnnn {} { !otGrau-S } { AnnaLenaRotGrauS } { Anna-Lena \prot_nbsp: Rot ~ Grau-S . }
	}
%</test|expect>
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\prot_newperson:nnnnnn}
%   Nimmt \marg{id}, \marg{name}, \marg{first_name}, \marg{last_name}, \marg{group}, \marg{attendance}, \marg{special}, \marg{voter}.
%   Zuvor müssen diese bereits befüllt werden.
%   Dabei werden \marg{id} und \marg{name} von \prot_newperson_frontend:nnnnnn und \marg{group} und \marg{voter} protokollspezifisch festgelegt.
%   \item Der Anzeigename \meta{name} wird anhand des \meta{shortname}-Arguments festgelegt.
%   \item Die \meta{id} wird falls vorhanden und nichtleer durch das \meta{id}-Argument und andernfalls gleich zu \meta{name} festgelegt.
%   Sollte \cs{\meta{id}} bereits definiert sein, wird ein Fehler erzeugt und das Anlegen der Person abgebrochen. Ansonsten wird \cs{\meta{id}} als \meta{name} mit folgendem |\@\xspace| definiert.
%   \NB{Das |\@| sorgt dafür, dass Abstände wie bei einem normalen Wortende (also einem Kleinbuchstaben) gesetzt werden, auch wenn der Name möglicherweise mit einem Punkt oder Großbuchstaben enden sollte.}
%
%   Zuerst wird geschaut, ob die \meta{id} ein Commandstring werden kann und dann in \cs{g@@_names_prop} die \meta{id} hinterlegt bzw\@. gemeckert, falls \meta{name} bereits belegt ist.
%    \begin{macrocode}
%<*package>
	\prop_new:N \g@@_names_prop
	\str_new:N \l@@_samename_id_str
	\cs_new_protected_nopar:Nn\prot_newperson:nnnnnn {
		\@@_tl_if_alphabetic:nTF {#1} {
			\cs_if_exist:cTF {#1} {
				\cs_if_exist:cTF { c_prot_person_/#1/id_str }
					{ \msg_error:nnn { prot } { person / id-exists } {#1} }
					{ \msg_error:nnn { prot } { person / id-iscsname } {#1} }
			} {
				\tl_const:cn {#1} { #2\@\xspace }
				\prop_get:NnNTF \g@@_names_prop {#2} \l@@_samename_id_str
					{ \msg_error:nnnnV { prot } { person / name-exists } {#2} {#1} \l@@_samename_id_str }
					{ \prop_gput:Nnn \g@@_names_prop {#2} {#1} }
%    \end{macrocode}
%   Danach werden unter \texttt{g_prot_person_/\meta{id}/} verschiedene Schlüssel befüllt:
%   |name|, |name/full|, |name/first|, |name/last|, |name/sort|, |attendance|, |group|.
%    \begin{macrocode}
				\str_set:Nn \l@@_person_str { prot_person_/#1 }
				\str_const:cn { c_\l@@_person_str/id_str } {#1}
				\tl_const:cn { c_\l@@_person_str/name_tl } {#2}
				\tl_const:cn { c_\l@@_person_str/name/first_tl } {#3}
				\tl_const:cn { c_\l@@_person_str/name/last_tl } {#4}
				\@@_parse_attendance:n {#6}
				\@@_set_attendance:
				\@@_apply_group:n {#5}
				\@@_initialize_move:
				\@@_add_to_attendance_list:vv { g_\l@@_person_str / group_str } { c_\l@@_person_str/attendance_str }
			}
		} { \msg_error:nnn { prot } { person / malformed-id } {#1} }
	}
	\str_new:N \l@@_person_str
%</package>
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_parse_attendance:n, \@@_set_attendance:n}
%   Über das Anwesenheitsfeld wird die Anwesenheit als ein Single-Choice-Wert definiert,
%   üblicherweise eins aus: x (anwesend), d (digital), e (entschuldigt), u (unentschuldigt).
%   Zusätzlich können hier noch weitere Attribute festgelegt werden: p (Protokoll), s (Sitzungsleitung)
%   beide setzen den Säumniswert für die Anwesenheit auf „x“ und rufen |\...| auf, was in der Person
%   einen Schalter setzt und die Person in der Liste für Protokoll/Sitzungsleitung einträgt.
%
%   Verschiedene Anwesenheitsmarker können als Schlüssel unter \emph{/prot/attendance/} angelegt werden.
%   Jede Gruppe ist implementiert als Menge an Personen. Zudem ist unter
%   \texttt{/prot/person/\meta{id}/group} die primäre Gruppe hinterlegt, wobei spätere Angaben vorherige überschreiben.
%
%   TODO: Implementiere mehrere Zeilen für eine Person.
%   TODO: Momentan wird der attendance-Schlüssel gar nicht genutzt. specials ebenso.
%    \begin{macrocode}
%<*package>
	\cs_new_protected_nopar:Nn \@@_parse_attendance:n {
		\str_new:c { g_\l@@_person_str/specials_str }
		\keys_set:nn { prot / attendance } { value =, fallback = u, #1 }
		\str_if_empty:NT \l@@_attendance_str { \str_set_eq:NN \l@@_attendance_str \l@@_attendance_fallback_str }
	}
	\cs_new_protected_nopar:Nn \@@_set_attendance: {
		\bool_new:c { g_\l@@_person_str/there_bool }
		\keys_set:nV { prot / attendance / use } \l@@_attendance_str
		\@@_provide:Ncn \tl_const:cv { c_\l@@_person_str/attendance/disp_tl } { c_\l@@_person_str/attendance_str }
	}
	\keys_define:nn { prot / attendance } {
		, value .str_set:N = \l@@_attendance_str
		, fallback .str_set:N = \l@@_attendance_fallback_str
		, attendance .code:n = { \str_const:cn { c_ \l@@_person_str / attendance_str } {#1} }
		, attendance/disp .code:n = { \tl_const:cn { c_ \l@@_person_str / attendance/disp_tl } { \exp_not:n{#1} } }
		% Koennte auch direkt ein bool sein
		, there .code:n = { \bool_gset:cn { g_ \l@@_person_str / there_bool } { \int_compare_p:nNn {#1} > 0 } }
		, protokoll .code:n = { \seq_gput_right:NV \g_prot_protokollfuehrung_seq \l@@_id_str }
		, sitzungsleitung .code:n = { \seq_gput_right:NV \g_prot_sitzungsfuehrung_seq \l@@_id_str }
		, x .meta:n = { value = x }, use/x .meta:n = { attendance = x, there = 1 }
		, e .meta:n = { value = e }, use/e .meta:n = { attendance = e, there = 0 }
		, u .meta:n = { value = u }, use/u .meta:n = { attendance = u, there = 0 }
		, d .meta:n = { value = d }, use/d .meta:n = { attendance = d, there = 1, attendance/disp = \emph x }
		, p .meta:n = { fallback = x, special = p, protokoll }
		, s .meta:n = { fallback = x, special = s, sitzungsleitung }
	}

%</package>
%    \end{macrocode}
%   Testing Attendance parsing and setting.
%    \begin{macrocode}
%<*test|expect>
\TEST { \@@_parse_attendance:n , \@@_set_attendance: } {
%<*test>
	\cs_new_protected_nopar:Nn \@@_test_attendance_i:nnn {
		\str_set:Nn \l@@_person_str {prot_person_/#1}
		\@@_parse_attendance:n {#2}
		\TYPE { \l@@_attendance_str }
	}
	\cs_new_protected_nopar:Nn \@@_test_attendance:nnnnn {
		\str_set:Nn \l@@_person_str {prot_person_/#1}
		\@@_parse_attendance:n {#2}
		\@@_set_attendance:
		\TYPE { attendance = \str_use:c { c_prot_person_/#1/attendance_str } }
		\TYPE { there = \bool_to_str:c { g_prot_person_/#1/there_bool } }
		\TYPE { disp = \tl_use:c { c_prot_person_/#1/attendance/disp_tl } }
	}
%</test>
%<*expect>
	\cs_new_protected_nopar:Nn \@@_test_attendance_i:nnn { \TYPE {#3} }
	\cs_new_protected_nopar:Nn \@@_test_attendance:nnnnn { \TYPE {attendance=#3} \TYPE {there=#4} \TYPE {disp=#5} }
%</expect>
	\@@_test_attendance_i:nnn A { x } { x }
	\@@_test_attendance_i:nnn B { p } { x }
	\@@_test_attendance_i:nnn C { u } { u }
	\@@_test_attendance_i:nnn D { d } { d }
	\@@_test_attendance_i:nnn E { x, e } { e }
	\@@_test_attendance_i:nnn F { e, x } { x }
	\@@_test_attendance:nnnnn G { x } x { true } { x }
	\@@_test_attendance:nnnnn H { p } x { true } { x }
	\@@_test_attendance:nnnnn I { u } u { false } { u }
	\@@_test_attendance:nnnnn J { d } d { true } { \exp_not:N\emph x }
	\@@_test_attendance:nnnnn K { x, e } e { false } { e }
	\@@_test_attendance:nnnnn L { e, x } x { true } { x }
}
%</test|expect>
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_add_to_attendance_list:nn, \prot_add_attendance_section:nn}
%   TODO: Dokumentation
%    \begin{macrocode}
%<*package>
	\cs_new_protected_nopar:Nn \@@_add_to_attendance_list:nn {
		\keys_set:nn { prot / attendance_list } { #1 = #2 }
	}
	\cs_generate_variant:Nn \@@_add_to_attendance_list:nn { vv }

	\tl_new:N \l_prot_attendance_sections_tl
	\cs_set_eq:NN \prot_attendance_section_hook:nn \prot_attendancelist_item:nn
	\cs_new_protected_nopar:Nn \prot_add_attendance_section:nn {
		\seq_new:c { l_prot_attendance_section_#1_seq }
		\keys_define:nn { prot / attendance_list} { #1 .code:n = {
			\seq_put_right:cV { l_prot_attendance_section_#1_seq } \l@@_id_str
		} }
		\tl_put_right:Nn \l_prot_attendance_sections_tl { \prot_attendance_section_hook:nn {#1} {#2} }
	}

	\keys_define:nn { prot / attendance_list } {
		, f .choice:
		, g .choice:
		, g / unknown .code:n = {}
	}

	\prot_add_attendance_section:nn { f / x } { Anwesende }
	\prot_add_attendance_section:nn { f / e } { Entschuldigte }
	\prot_add_attendance_section:nn { f / u } { Unentschuldigte }
	\prot_add_attendance_section:nn { g / x } { Gäste }
	\prot_add_attendance_section:nn { stupa } { StuPa }
%</package>
%    \end{macrocode}
%   Some tests:
%    \begin{macrocode}
%<*test|expect>
	\TEST { \@@_add_to_attendance_list:nn } {
%<*test>
	\seq_new:N \l_prot_attendance_section_ignored_seq
	\seq_put_right:Nn \l_prot_attendance_section_ignored_seq { --ignored-- }
	\cs_new_protected_nopar:Nn \@@_test_add_to_attendance_list:nnnnn {
		\str_set:Nn \l@@_id_str {#1}
		\@@_add_to_attendance_list:nn {#2} {#3}
		\TYPE { #2 / #3 ~=~ \seq_use:cn { l_prot_attendance_section_#4_seq } {,~} }
	}
%</test>
%<*expect>
	\cs_new_protected_nopar:Nn \@@_test_add_to_attendance_list:nnnnn {
		\TYPE { #2 / #3 ~=~ #5 }
	}
%</expect>
	\@@_test_add_to_attendance_list:nnnnn @ { f } { x } { f / x } { @ }
	\@@_test_add_to_attendance_list:nnnnn A { f } { x } { f / x } { @ ,~ A }
	\@@_test_add_to_attendance_list:nnnnn B { f } { u } { f / u } { B }
	\@@_test_add_to_attendance_list:nnnnn C { g } { x } { g / x } { C }
	\@@_test_add_to_attendance_list:nnnnn D { g } { a } { ignored } { --ignored-- }
	\@@_test_add_to_attendance_list:nnnnn E { g } { }  { ignored } { --ignored-- }
	\@@_nontest:nn { } { \msg_error:nnnn { keys } { unknown } { prot / attendance_list / undef } { prot / attendance_list } }
	\@@_test_add_to_attendance_list:nnnnn F { undef } { x } { ignored } { --ignored-- }
	\@@_test_add_to_attendance_list:nnnnn G { stupa } { } { stupa } { G }
	}
%</test|expect>
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_apply_group:n}
%    \begin{macrocode}
%<*package>
	\cs_new_protected_nopar:Nn \@@_apply_group:n {
		\str_new:c { g_\l@@_person_str / group_str }
		\keys_set_known:nn { prot / group } {#1}
		\@@_provide:Ncn \cs_new_protected_nopar:cn { \l@@_person_str / aftermove:N } { }
		\tl_if_empty:cT { g_\l@@_person_str / group_str } { \keys_set:nn { prot / group } { g } }
	}
	\keys_define:nn { prot / group } {
		, voter .code:n = { \cs_new_protected_nopar:cpn { \l@@_person_str / aftermove:N } { \@@_move_voter:N } }
		, groupvoter .code:n = { \@@_make_groupvoter:Vn \l@@_id_str {#1} }
		, group .code:n = {
			\str_gset:cn { g_ \l@@_person_str / group_str } {#1}
			\seq_gput_right:cV { g_prot_group_#1_seq } \l@@_id_str
		}
		, votergroup .meta:n = { group = #1, groupvoter = #1 }
		, info .code:n = { \tl_const:cn { \l@@_person_str / info_tl } {#1} }
		, g .meta:n = { group = g, info = #1 }
		, f .meta:n = { group = f, voter }
		, r .meta:n = { group = f, special = r }
	}
	\seq_new:N \g_prot_group_f_seq
	\seq_new:N \g_prot_group_g_seq
	\int_new:N \g_prot_voters_int
	\cs_new_protected_nopar:Nn \@@_move_voter:N {
		\bool_if:NTF {#1}
			{ \int_gincr:N \g_prot_voters_int }
			{ \int_gdecr:N \g_prot_voters_int }
	}
	\cs_new_protected_nopar:Nn \@@_make_groupvoter:nn {
		\cs_new_protected_nopar:cpn { prot_person_/ #1 / aftermove:N } { \@@_move_groupvoter:nnN {#1} {#2} }
	}
	\cs_generate_variant:Nn \@@_make_groupvoter:nn { Vn }
	\cs_new_protected_nopar:Nn \@@_move_groupvoter:nnN {
		\bool_if:NTF #3
			\@@_enter_groupvoter:cn
			\@@_leave_groupvoter:cn
		{ g_prot_votergroup_#2_seq } {#1}
	}
	\cs_new_protected_nopar:Nn \@@_leave_groupvoter:Nn {
		\seq_if_in:NnTF #1 {#2} {
			\seq_gremove_all:Nn #1 {#2}
			\seq_if_empty:NT #1 {
				\int_gdecr:N \g_prot_voters_int
			}
		} {
			\msg_error:nnn { prot } { move / wrong-groupvoter } {#2}
		}
	}
	\cs_new_protected_nopar:Nn \@@_enter_groupvoter:Nn {
		\seq_if_in:NnTF #1 {#2} {
			\msg_error:nnn { prot } { move / wrong-groupvoter } {#2}
		} {
			\seq_if_empty:NT #1 {
				\int_gincr:N \g_prot_voters_int
			}
			\seq_gput_right:Nn #1 {#2}
		}
	}
	\cs_generate_variant:Nn \@@_leave_groupvoter:Nn { c }
	\cs_generate_variant:Nn \@@_enter_groupvoter:Nn { c }
%</package>
%    \end{macrocode}
%   For tests see at the very end.
% \end{macro}
% \begin{macro}{attendance/special, group/special, \sitzungsfuehrung, \protokollfuehrung}
%   TODO: Dokumentation
%    \begin{macrocode}
%<*package>
	\keys_define:nn { prot } {
		, attendance/special .code:n = { \str_gput_right:cn { g_ \l@@_person_str / specials_str } {#1} }
		, group/special .code:n = { \str_gput_right:cn { g_ \l@@_person_str / specials_str } {#1} }
	}

	\seq_new:N \g_prot_sitzungsfuehrung_seq
	\seq_new:N \g_prot_protokollfuehrung_seq

	\NewDocumentCommand \sitzungsfuehrung { } {
		\seq_if_empty:NTF \g_prot_sitzungsfuehrung_seq {
			\msg_error:nn { prot } { person / no-leader }
		} {
			\seq_set_map_x:NNn \l_tmpa_seq \g_prot_sitzungsfuehrung_seq { \prot_fullname:n {##1} }
			\seq_use:Nn \l_tmpa_seq { ,~ }
		}
	}
	\NewDocumentCommand \protokollfuehrung { } {
		\seq_if_empty:NTF \g_prot_protokollfuehrung_seq {
			\msg_error:nn { prot } { person / no-record }
		} {
			\seq_set_map_x:NNn \l_tmpa_seq \g_prot_protokollfuehrung_seq { \prot_fullname:n {##1} }
			\seq_use:Nn \l_tmpa_seq { ,~ }
		}
	}
%</package>
%    \end{macrocode}
%   TODO: Some tests:
%    \begin{macrocode}
%<*test|expect>
	\BEGINTEST {special, sitzungsfuehrung, protokollfuehrung}
%<*test>
%</test>
%<*expect>
%</expect>
	\ENDTEST
%</test|expect>
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\prot_move:Nn, \@@_initialize_move:}
%   Momentane Implementierung: Alle Menschen kommen automatisch, wenn sie mit |x| oder dergleichen angelegt sind.
%   Beim Einlesen der |.aux|-Datei gehen alle, deren erste Interaktion ein Kommen ist.
%   Bei allen späteren Bewegungen prüfe, ob dies die erste Bewegung ist und falls diese ein Kommen ist, schreibe in die |.aux|-Datei ein (nicht als erste Bewegung zählendes Gehen (siehe vorheriger Punkt)).
%   Bei einer nicht-ersten Bewegung hingegen verifiziere, dass diese das Gegenteil der vorherigen Anwesenheit ist.
%
%   \cs{prot_move:Nn} setzt momentane Anwesenheit \cs{g_prot_person_/#2/there_bool} von #2=\meta{id} auf |#1|.
%   Schaut in \cs{g_prot_person/#2/moves_tl} nach,
%   ob die Person sich nicht bewegen darf (nicht da ist) (kodiert als „-“),
%   ob sie sich noch nicht bewegt hat (kodiert als „0“) – und schreibt dann in die |.aux|-Datei – oder
%   ob sie sich bereits bewegt hat (kodiert als „+“) und prüft dann auf Konsistenz.
%   Nutzt |forcemove| ohne Tests und für personenabhängige Zwecke, was zusätzlich \cs{prot_person_/#2/aftermove:N} aufruft.
%    \begin{macrocode}
%<*package>
	\cs_new_protected_nopar:Nn \prot_move:Nn {
		\exp_args:Nv \str_case:nnF { g_prot_person_/#2/moves_tl } {
			- { \msg_error:nnn { prot } { move / not-there } {#2} }
			0 {
				\tl_gset:cn { g_prot_person_/#2/moves_tl } {+}
				\bool_if:NT #1 { \@@_addlate:n {#2} }
				\@@_forcemove:Nn #1 {#2}
			}
		} {
			\bool_xor:nnTF { \bool_if_p:c { g_prot_person_/#2/there_bool } } {#1} {
				\@@_forcemove:Nn #1 {#2}
			} { \exp_args:Nnx \msg_error:nnn { prot } { move / \bool_to_str:n {#1} - again } {#2} }
		}
	}
	\cs_new_protected_nopar:Nn \@@_initialize_move: {
		\tl_new:c { g_\l@@_person_str/moves_tl }
		\bool_if:cTF { g_\l@@_person_str/there_bool } {
			\tl_gset:cn { g_\l@@_person_str/moves_tl } 0
			\use:c { \l@@_person_str/aftermove:N } \c_true_bool
		} { \tl_gset:cn { g_\l@@_person_str/moves_tl } - }
	}
	\cs_new_protected_nopar:Nn \@@_forcemove:Nn {
		\bool_gset_eq:cN { g_prot_person_/#2/there_bool } #1
		\use:c { prot_person_/#2/aftermove:N } #1
	}
	\cs_new_protected_nopar:Nn \@@_addlate:n {
		\iow_now:Nn \@mainaux { \@@_makelate:n {#1} }
	}
	\cs_new_protected_nopar:Nn \@@_makelate:n { \@@_forcemove:Nn \c_false_bool {#1} }
%</package>
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\peoplemove, \peopleenter, \peopleleave}
%   TODO: Hübsche Doku
%   \cmd\peoplemove\arg{\cs a\cs b\cs c}\arg{\cs x\cs y\cs z} lässt die Personen |a|, |b| und |c| kommen und |x|, |y|, |z| gehen.
%   \cmd\peoplemovetext produziert einen Text im Input-Stream, der beispielsweise in einen \cmd\metapar eingebettet werden kann.
%   \cmd{\peopleenter} und \cmd{\peopleleave} lassen einfach eins der beiden Argumente leer.
%    \begin{macrocode}
%<*package>
	\cs_new_nopar:Npn \peopleenter { \prot_multimove:Nn \c_true_bool }
	\cs_new_nopar:Npn \peopleleave { \prot_multimove:Nn \c_false_bool }
	\cs_new_nopar:Npn \peoplemove #1 #2 { \peopleenter {#1} \peopleleave {#2} }
	\cs_new_nopar:Nn \prot_move:NN { \exp_args:NNe \prot_move:Nn #1 { \cs_to_str:N #2 } }
	\cs_new_nopar:Nn \prot_multimove:Nn { \tl_map_tokens:nn {#2} { \prot_move:NN #1 } }
	\cs_new_nopar:Npn \peopleentertext #1 { \prot_tl_use_german:n {#1} ~ \prot_enter_german:n {#1} ~die~Sitzung. }
	\cs_new_nopar:Npn \peopleleavetext #1 { \prot_tl_use_german:n {#1} ~ \prot_leave_german:n {#1} ~die~Sitzung. }
	\cs_new_nopar:Npn \peoplemovetext #1 #2 { \prot_tl_use_german:n {#1} ~ \prot_enter_german:n {#1} ~und~ \prot_tl_use_german:n {#2} ~ \prot_leave_german:n {#2} ~die~Sitzung. }
	\cs_new_nopar:Nn \prot_enter_german:n { \tl_if_single:nTF {#1} { \exp_not:n {betritt} } { \exp_not:n {betreten} } }
	\cs_new_nopar:Nn \prot_leave_german:n { \tl_if_single:nTF {#1} { \exp_not:n {verlässt} } { \exp_not:n {verlassen} } }
%</package>
%    \end{macrocode}
%   Some tests:
%    \begin{macrocode}
%<*test|expect>
	\BEGINTEST { \peoplemove, ..., \peoplemovetext, ... }
%<*test>
	\cs_set_nopar:Nn \prot_move:Nn { \TYPE { ~--~ #2 ~ \bool_if:NTF #1 { kommt } { geht } } }
%</test>
	\@@_test:nn { \peopleenter \Anna } { ~--~ Anna~kommt }
	\@@_test:nn { \peopleleave { \Anna \Bea } } { ~--~ Anna~geht ~--~ Bea~geht }
	\@@_test:nn { \peoplemove { \Anna \Bea \Carla } {} } { ~--~ Anna~kommt ~--~ Bea~kommt ~--~ Carla~kommt }
	\@@_test:nn { \peoplemove \Anna { \Bea \Carla } } { ~--~ Anna~kommt ~--~ Bea~geht ~--~ Carla~geht }
	\@@_tltest:nn { \peopleentertext { { Anná } } } { Anná~betritt~die~Sitzung. }
	\@@_tltest:nn { \peopleleavetext { { Anna } } } { Anna~verlässt~die~Sitzung. }
	\@@_tltest:nn { \peopleentertext { { Anna } { Bea } } } { Anna~und~Bea~betreten~die~Sitzung. }
	\@@_tltest:nn { \peopleleavetext { { Anna } { Bea } { Carla } } } { Anna,~Bea~und~Carla~verlassen~die~Sitzung. }
	\@@_tltest:nn { \peoplemovetext { { Anna } { Bea } { Carla } } { { Xaver } } } { Anna,~Bea~und~Carla~betreten~und~Xaver~verlässt~die~Sitzung. }
	\@@_tltest:nn { \peoplemovetext { { Xaver } } { { Anna } { Bea } { Carla } } } { Xaver~betritt~und~Anna,~Bea~und~Carla~verlassen~die~Sitzung. }
	\@@_tltest:nn { \peopleleavetext {} } { ~verlassen~die~Sitzung. }
	\ENDTEST
%</test|expect>
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\prot_voting:n, \prot_simple_voting:n}
%   Nimmt eine tokenlist als Argument und lässt ein Ergebnis im Input Stream.
%   \cs{prot_simple_voting:n} tut dies direkt, wohingegen \cs{prot_voting:n} noch etwas mehr erledigt:`
%   Enthält die tokenlist nur Zahlen, gebe das Ergebnis aus und überprüfe zudem, ob die Summe der Zahlen gleich der momentanen Anzahl Stimmberechtigter ist.
%   Enthält die tokenlist einen Stern und sonst nur Zahlen, so ersetze den Stern so durch eine Zahl, dass die Summe wie im vorigen Satz passt.
%   In allen anderen Fällen gibt es einen Fehler.
%    \begin{macrocode}
%<*package>
	\NewDocumentCommand\erg { m m m } { \prot_voting:n { {#1} {#2} {#3} } }
	\NewDocumentCommand\Erg { m m m } { \prot_simple_voting:n { {#1} {#2} {#3} } }
	\NewDocumentCommand\ergwahl { m m } { \prot_voting:n { {#1} {#2} } }
	\NewDocumentCommand\Ergwahl { m m } { \prot_simple_voting:n { {#1} {#2} } }
	\int_new:N \l@@_votes_int
	\int_new:N \l@@_votes_stars_int
	\seq_new:N \l@@_result_seq
	\tl_const:Nn \c_prot_vote_sep_tl { \exp_not:N\, / \exp_not:N\, }
	\cs_new_protected_nopar:Nn \prot_voting:n {
		\int_zero:N \l@@_votes_int
		\int_zero:N \l@@_votes_stars_int
		\seq_clear:N \l@@_result_seq
		\tl_map_inline:nn {#1} {
			\str_if_eq:nnTF {##1} * {
				\int_incr:N \l@@_votes_stars_int
				\seq_put_right:Nn \l@@_result_seq { \int_eval:n { \g_prot_voters_int - \l@@_votes_int } }
			} {
				\int_add:Nn \l@@_votes_int {##1}
				\seq_put_right:Nn \l@@_result_seq {##1}
			}
		}
		\bool_if:nT {
			\int_compare_p:nNn \l@@_votes_stars_int = 0
			&& ! \int_compare_p:nNn \l@@_votes_int = \g_prot_voters_int
		} {
			\msg_warning:nnxxx { prot } { voting / wrong-count }
				{ \seq_use:Nn \l@@_result_seq + }
				{ \int_use:N \l@@_votes_int }
				{ \int_use:N \g_prot_voters_int }
		}
		\int_compare:nNnTF \l@@_votes_stars_int < 2
			{ \@@_simple_seq_voting:N \l@@_result_seq }
			{ \msg_error:nnn { prot } { voting / super-stars } {#1} }
	}
	\cs_new_nopar:Nn \@@_simple_seq_voting:N { ( \seq_use:Nn #1 \c_prot_vote_sep_tl ) }
	\cs_new_nopar:Nn \prot_simple_voting:n { ( \@@_tl_use:nn {#1} \c_prot_vote_sep_tl ) }
%</package>
%    \end{macrocode}
% Tests:
%    \begin{macrocode}
%<*test|expect>
	\group_begin:
	\TEST { \prot_voting:n } {
%<*test>
	\cs_set_eq:NN \@@_test_simple_seq_voting:N \@@_simple_seq_voting:N
	\cs_set_nopar:Nn \@@_simple_seq_voting:N { \exp_args:Nx \TYPE { \@@_test_simple_seq_voting:N \l@@_result_seq } }
	\cs_new_protected_nopar:Nn \@@_test_voting:nn { \prot_voting:n {#1} }
	\cs_new_nopar:Nn \@@_test_voting:nnn { \@@_test_voting:nn {#1} {} }
%</test>
%<*expect>
	\cs_new_nopar:Nn \@@_test_voting:nn { \TYPE { \prot_simple_voting:n {#2} } }
	\cs_new_nopar:Nn \@@_test_voting:nnn { #3 \@@_test_voting:nn {} {#2} }
%</expect>
	\@@_test:nn { \prot_simple_voting:n {abc} } { ( a \c_prot_vote_sep_tl b \c_prot_vote_sep_tl c ) }
	\@@_test:nn { \prot_simple_voting:n {a} } { ( a ) }
	\@@_test:nn { \prot_simple_voting:n {} } { ( ) }
	\int_gset:Nn \g_prot_voters_int { 21 }
	\@@_test_voting:nn { 0123456 } { 0123456 }
	\@@_test_voting:nn { 012345* } { 0123456 }
	\@@_test_voting:nn { 0123*56 } { 0123456 }
	\@@_test_voting:nn { 0*23456 } { 0123456 }
	\@@_test_voting:nn { *123456 } { 0123456 }
	\@@_test_voting:nn { 5{10}* } { 5{10}6 }
	\@@_test_voting:nn { *1 } { {20}1 }
	\@@_test_voting:nn { * } { {21} }
	\@@_test_voting:nnn{ 1123456 } { 1123456 } { \msg_warning:nnnnn { prot } { voting / wrong-count } { 1+1+2+3+4+5+6 } { 22 } { 21 } }
	\@@_nontest:nn { \prot_voting:n { *12345* } } { \msg_error:nnn { prot } { voting / super-stars } { *12345* } }
	\int_gzero:N \g_prot_voters_int
	}
	\group_end:
%</test|expect>
%    \end{macrocode}
% \end{macro}
% \subsection{Zusätzliche Kernel-Funktionen}
%    \begin{macrocode}
%<*package>
	\cs_new:Nn \@@_tl_use:nn {
		\tl_head:n {#1} \exp_args:Ne \tl_map_tokens:nn { \tl_tail:n {#1} } { \use:nn {#2} }
	}
	\cs_new:Nn \@@_seq_to_tl:N { \seq_map_function:NN #1 \@@_exp_not_braced:n }
	\cs_new:Nn \@@_exp_not_braced:n { \exp_not:n { {#1} } }
	\regex_const:Nn \c@@_alph_regex { \A[A-Za-z]*\Z }
	\cs_new_nopar:Npn \@@_tl_if_alphabetic:nTF { \regex_match:NnTF \c@@_alph_regex }
	\cs_new_protected:Npn \@@_provide:Ncn #1#2#3 { \cs_if_exist:cF {#2} { #1 {#2} {#3} } }
	\cs_new_protected:Npn \@@_provide:Nc #1#2 { \cs_if_exist:cF {#2} { #1 {#2} } }
	\cs_new:Nn \@@_args_ii_ii:Nn { #1 {#2} {#2} }
	%\cs_new_protected:Npn \@@_tl_use:nnnn #1 {
		%\seq_set_split:Nnn \l_tmpa_seq {} {#1}
		%\seq_use:Nnnn \l_tmpa_seq
	%}
	\scan_new:N \s@@_tl_mark
	\scan_new:N \s@@_tl_stop
	\cs_new:Npn \@@_use_none_delimit_by_s_tl_stop:w #1 \s@@_tl_stop { }
	\cs_new:Nn \prot_tl_use:nnnn {
		\int_case:nnF { \tl_count:n {#1} } {
			{ 0 } { }
			{ 1 } { \@@_tl_use:nnn #1 { } { } }
			{ 2 } { \@@_tl_use:nnn #1 {#2} }
		} {
			\@@_tl_use:nwnn #1 \s@@_tl_stop
			\s@@_tl_mark
			{#3} {#4}
		}
	}
	\cs_new:Nn \@@_tl_use:nnn { \exp_not:n { #1 #3 #2 } }
	\cs_new:Npn \@@_tl_use:nwnn #1#2 \s@@_tl_mark { \@@_tl_use:nnwnnn #2 \s@@_tl_mark {#1} }
	\cs_new:Npn \@@_tl_use:nnwnnn #1#2#3 \s@@_tl_mark #4 #5 #6 {
		\@@_use_none_delimit_by_s_tl_stop:w #2
		\@@_tl_use_finalone:nwnnn { #4 #6 #1 } \s@@_tl_stop
		\@@_tl_use:nnwnnn {#2} #3 \s@@_tl_mark { #4 #5 #1 } {#5} {#6}
	}
	\cs_new:Npn \@@_tl_use_finalone:nwnnn #1#2 \s@@_tl_mark #3 #4 #5 { \exp_not:n {#1} }
	\cs_new_nopar:Nn \prot_tl_use_german:n { \prot_tl_use:nnnn {#1} { ~und~ } { ,~ } { ~und~ } }
	\cs_generate_variant:Nn \tl_range:nnn { nne }
	\cs_generate_variant:Nn \tl_const:Nn { cv }
	\cs_generate_variant:Nn \seq_set_map:NNn { Nc }
	\cs_generate_variant:Nn \seq_set_map_x:NNn { Nc }
	\cs_generate_variant:Nn \msg_error:nnnnn { nnnnV }
%</package>
%    \end{macrocode}
%   Tests für einige der zusätzlichen Kernel-Funktionen
%    \begin{macrocode}
%<*test|expect>
	\BEGINTEST { \prot_tl_use:nnnn }
	\@@_test:nn { \prot_tl_use:nnnn { } + , | } { }
	\@@_test:nn { \prot_tl_use:nnnn { a } + , | } { a }
	\@@_test:nn { \prot_tl_use:nnnn { a b } + , | } { a + b }
	\@@_test:nn { \prot_tl_use:nnnn { a b c } + , | } { a , b | c }
	\@@_test:nn { \prot_tl_use:nnnn { a b c d } + , | } { a , b , c | d }
	\@@_test:nn { \prot_tl_use:nnnn { {aa} } + , | } { aa }
	\@@_test:nn { \prot_tl_use:nnnn { {aa} {bb} } + , | } { aa + bb }
	\@@_test:nn { \prot_tl_use:nnnn { {aa} {bb} {cc} } + , | } { aa , bb | cc }
	\@@_test:nn { \prot_tl_use:nnnn { {aa} {bb} {cc} {dd} } + , | } { aa , bb , cc | dd }
	\@@_tltest:nn { \prot_tl_use:nnnn { \q_nil \q_nil \q_nil } \q_no_value \q_mark \q_stop } { \q_nil \q_mark \q_nil \q_stop \q_nil }
	\@@_test:nn { \prot_tl_use_german:n { a b c d } } { a,~b,~c~und~d }
	\@@_test:nn { \prot_tl_use_german:n { {Anna} {Bea} {Charlie} {Dora} } } { Anna,~Bea,~Charlie~und~Dora }
	\ENDTEST
%</test|expect>
%    \end{macrocode}
% \subsection{Fehlermeldungen}
%    \begin{macrocode}
%<*package>
	\msg_new:nnnn { prot } { persontable / col-count } { Die~Personentabellenzeile~'#1'~enthaelt~#2~statt~6~Spalten. } { In~jeder~Spalte~muessen~genau~5~\&-Zeichen~stehen. }
	\msg_new:nnnn { prot } { person / no-leader } { Es~gibt~keine~Sitzungsleitung. } { In~der~Personentabelle~muss~eine~Sitzungsleitung~eingetragen~werden. }
	\msg_new:nnnn { prot } { person / no-record } { Es~gibt~keine~Protokollfuehrung. } { In~der~Personentabelle~muss~eine~Protkollfuehrung~eingetragen~werden. }
	\msg_new:nnnn { prot } { person / malformed-id } { Die~ID~'#1'~ist~boese. } { Ids~duerfen~nur~die~Buchstaben~A-Z~und~a-z~enthalten.~Keine~Umlaute~oder~sonstigen~Schnickschnack. }
	\msg_new:nnn  { prot } { person / id-exists } { Die~ID~'#1'~ist~bereits~an~jemand~anderen~vergeben. }
	\msg_new:nnn  { prot } { person / id-iscsname } { Die~ID~'#1'~existiert~bereits~als~LaTeX-Makro. }
	\msg_new:nnnn { prot } { person / name-exists } { Der~Name~'#1'~fuer~'#2'~ist~bereits~an~'#3'~vergeben. } { Dies~koennte~Teile~der~Bevoelkerung~verwirren. }
	\msg_new:nnnn { prot } { move / wrong-groupvoter } { Programmierfehler:~'#1'~bewegt~sich~illegal. } { Eigentlich~sollte~dies~vorher~abgefangen~werden. }
	\msg_new:nnnn { prot } { move / not-there } { '#1'~bewegt~sich,~war~aber~gar~nicht~auf~der~Sitzung. } { Vielleicht~war~sie~doch~anwesend? }
	\msg_new:nnnn { prot } { move / 0-again } { '#1'~geht~zwei~mal~hintereinander. } { Vielleicht~kam~sie~zwischendrin~wieder? }
	\msg_new:nnnn { prot } { move / 1-again } { '#1'~kommt~zwei~mal~hintereinander. } { Vielleicht~ging~sie~zwischendrin~wieder? }
	\msg_new:nnnn { prot } { voting / wrong-count } { Von~#3~anwesenden~Stimmberechtigten~haben~#1=#2~abgestimmt. } { Falls~das~so~richtig~ist,~nutze~die~\exp_not:N\Erg-Funktion. }
	\msg_new:nnnn { prot } { voting / super-stars } { Das~Abstimmungsergebnis~'#1'~enthaelt~zu~viele~Sterne. } { Es~kann~nur~einen~*S*t*a*r*~geben. }
%</package>
%    \end{macrocode}
% \subsection{Integration Tests}
%    \begin{macrocode}
%<*test|expect>
\group_begin:
%<*test>
	\seq_new:N \g_prot_group_stupa_seq
	\seq_new:N \g_prot_group_fsma_seq
	\seq_new:N \g_prot_group_reffs_seq
	\seq_new:N \g_prot_group_refvor_seq
	\seq_new:N \g_prot_votergroup_refvor_seq
	\keys_define:nn { prot / group } {
		% StuPa
		, stupa .meta:n = { group = stupa, voter }
		, fsma .meta:n = { group = fsma }
		, reffs .meta:n = { group = reffs }
		% AStA
		, refvor .meta:n = { votergroup = refvor }
	}
%</test>
\TEST { \@@_apply_group:n, \prot_move:Nn } {
	\setcounter{errorcontextlines}{100}
	\cs_new:Npn \@@_test_seq_use:c #1 { \seq_use:cn {#1} , }
	\cs_new:Npn \@@_test_use_if_exist:Nc #1#2 { \cs_if_exist:cT {#2} { #2 = #1 { #2 } } }
%<*test>
	\cs_new_protected_nopar:Nn \@@_test_group:nnnnnnn {
		\str_set:Nn \l@@_id_str {#1}
		\str_set:Nn \l@@_person_str { prot_person_/#1 }
		\cs_if_exist:cF { c_prot_person_/#1/id_str } {
			\str_const:cn { c_prot_person_/#1/id_str } {#1}
			\bool_new:c  { g_prot_person_/#1/there_bool }
		}
		\bool_gset:cn { g_prot_person_/#1/there_bool } { ! \str_if_eq_p:nn {#2} 0 }
		\@@_apply_group:n {#3}
		\TYPE { group = \str_use:c { g_prot_person_/#1/group_str } }
		\TYPE { \@@_test_use_if_exist:Nc \@@_test_seq_use:c { g_prot_group_#4_seq } }
		\@@_initialize_move:
		\TYPE { ##voters = \int_use:N \g_prot_voters_int }
		\TYPE { \@@_test_use_if_exist:Nc \@@_test_seq_use:c { g_prot_votergroup_#4_seq } }
	}
	\cs_new_protected_nopar:Nn \@@_test_move:nNnnn {
		\prot_move:Nn {#2} {#1}
		\TYPE { there = \bool_to_str:c { g_prot_person_/#1/there_bool } }
		\TYPE { ##voters = \int_use:N \g_prot_voters_int }
		\TYPE { \@@_test_use_if_exist:Nc \@@_test_seq_use:c { g_prot_votergroup_#3_seq } }
	}
	\cs_new_protected_nopar:Nn \@@_test_show_name:nn {
		\TYPE { \exp_not:n {#1} = \prop_item:Nn \g@@_names_prop {#1} }
	}
	\cs_new_protected_nopar:Nn \@@_test_show_person:nnnnn {
		\TYPE { id = \str_use:c { c_prot_person_/#1/id_str } }
		\TYPE { name = \exp_not:v { c_prot_person_/#1/name_tl } }
		\TYPE { group = \str_use:c { g_prot_person_/#1/group_str } }
		\TYPE { attendance = \str_use:c { c_prot_person_/#1/attendance_str } }
		\TYPE { there = \bool_to_str:c { g_prot_person_/#1/there_bool } }
	}
%</test>
%<*expect>
	\cs_new_protected_nopar:Nn \@@_test_group:nnnnnnn {
		\TYPE { group = #4 }
		\TYPE { \quark_if_nil:nF {#5} { g_prot_group_#4_seq = #5 } }
		\TYPE { ##voters = #6 }
		\TYPE { \quark_if_nil:nF {#7} { g_prot_votergroup_#4_seq = #7 } }
	}
	\cs_new_protected_nopar:Nn \@@_test_move:nNnnn {
		\TYPE { there = \bool_to_str:N #2 }
		\TYPE { ##voters = #4 }
		\TYPE { \tl_if_empty:nF {#3} { g_prot_votergroup_#3_seq = #5 } }
	}
	\cs_new_protected_nopar:Nn \@@_test_show_name:nn { \TYPE { \exp_not:n {#1} = #2 } }
	\cs_new_protected_nopar:Nn \@@_test_show_person:nnnnn {
		\TYPE { id = #1 }
		\TYPE { name = \exp_not:n{#2} }
		\TYPE { group = #3 }
		\TYPE { attendance = #4 }
		\TYPE { there = #5 }
	}
%</expect>
	\@@_test_group:nnnnnnn { Donaldy } 0 { g }      { g }  { Donaldy } 0 { \q_nil }
	\@@_test_group:nnnnnnn { Donald  } 1 { g }      { g }  { Donaldy , Donald } 0 { \q_nil }
	\SEPARATOR
	\@@_test_group:nnnnnnn { Anna    } 0 { stupa }  { stupa } { Anna } 0 { \q_nil }
	\@@_test_group:nnnnnnn { Bea     } 1 { stupa }  { stupa } { Anna , Bea } 1 { \q_nil }
	\@@_test_group:nnnnnnn { Charlie } 1 { stupa }  { stupa } { Anna , Bea , Charlie } 2 { \q_nil }
	\@@_test_group:nnnnnnn { Dora    } 1 { stupa }  { stupa } { Anna , Bea , Charlie , Dora } 3 { \q_nil }
	\SEPARATOR
	\@@_nontest:nn { \@@_makelate:n { Bea } } { }
	\@@_test_move:nNnnn    { Donald  } \c_false_bool { } 2 { }
	\@@_test:nn { } { \@@_makelate:n { Bea } }
	\@@_test_move:nNnnn    { Bea     } \c_true_bool  { } 3 { }
	\@@_test_move:nNnnn    { Charlie } \c_false_bool { } 2 { }
	\@@_test_move:nNnnn    { Bea     } \c_false_bool { } 1 { }
	\@@_test_move:nNnnn    { Dora    } \c_false_bool { } 0 { }
	\SEPARATOR
	\@@_test_group:nnnnnnn { Emilie } 0 { refvor }  { refvor } { Emilie } 0 { }
	\@@_test_group:nnnnnnn { Fynn   } 1 { refvor }  { refvor } { Emilie , Fynn } 1 { Fynn }
	\@@_test_group:nnnnnnn { Gerda  } 1 { refvor }  { refvor } { Emilie , Fynn , Gerda } 1 { Fynn , Gerda }
	\@@_test_group:nnnnnnn { Heidi  } 1 { refvor }  { refvor } { Emilie , Fynn , Gerda , Heidi } 1 { Fynn , Gerda , Heidi }
	\SEPARATOR
	\@@_nontest:nn { \@@_makelate:n { Gerda } } { }
	\@@_nontest:nn { \@@_makelate:n { Heidi } } { }
	\@@_test_move:nNnnn    { Donald } \c_true_bool  { refvor } 1 { Fynn }
	\@@_test:nn { } { \@@_makelate:n { Heidi } }
	\@@_test_move:nNnnn    { Heidi  } \c_true_bool  { refvor } 1 { Fynn , Heidi }
	\@@_test_move:nNnnn    { Fynn   } \c_false_bool { refvor } 1 { Heidi }
	\@@_test:nn { } { \@@_makelate:n { Gerda } }
	\@@_test_move:nNnnn    { Gerda  } \c_true_bool  { refvor } 1 { Heidi , Gerda }
	\@@_test_move:nNnnn    { Gerda  } \c_false_bool { refvor } 1 { Heidi }
	\@@_test_move:nNnnn    { Heidi  } \c_false_bool { refvor } 0 { }
}
\TEST { persontable } {
%<*test>
\begin{persontable}
\\ Nat & Nathan  & Weise    & !!   & stupa & x
\\ NW  & Nathan  & Waise    & !!   & stupa & e
\\     & Ada     & Lovelace &      & stupa & x
\\     & Eva     & Daus     & Eve  & g     & x
\\ Ron & Rönja   & Daus     &      & g     & x
\\
\\     & Evä     & Daus     &      & g     & x
\\     & Roman   & Leser    &      & g     & x
\\     & Ada     & Love     &      & stupa & x
\\ Eva & Eva     & Daus     & Eve  & g     & x
\\     & Nathan  & Weise    & !!   & stupa & u
\end{persontable}
%</test>
%<*expect>
	\msg_error:nnn { prot } { person / malformed-id } { Evä }
	\msg_error:nnn { prot } { person / id-iscsname } { Roman }
	\msg_error:nnn { prot } { person / id-exists } { Ada }
	\msg_error:nnnnn { prot } { person / name-exists } { Eve } { Eva } { Eve }
	\msg_error:nnnnn { prot } { person / name-exists } { Nathan\prot_nbsp: We. } { NathanWe } { Nat }
%</expect>
	\@@_test_show_person:nnnnn { Nat } { Nathan\prot_nbsp: We. } { stupa } { x } { true }
	\@@_test_show_person:nnnnn { NW  } { Nathan\prot_nbsp: Wa. } { stupa } { e } { false }
	\@@_test_show_person:nnnnn { Ada } { Ada } { stupa } { x } { true }
	\@@_test_show_person:nnnnn { Eve } { Eve } { g  } { x } { true }
	\@@_test_show_person:nnnnn { Ron } { Rönja } { g  } { x } { true }
	\@@_test_show_name:nn { Nathan\prot_nbsp: We. } { Nat }
	\@@_test_show_name:nn { Ada } { Ada }
	\@@_test_show_name:nn { Eve } { Eve }
	\@@_test_show_name:nn { Rönja } { Ron }
}
\group_end:
%</test|expect>
%    \end{macrocode}
% \subsection{And the end}
%    \begin{macrocode}
%<*test|expect>
	\ExplSyntaxOff
	\END
%</test|expect>
%    \end{macrocode}
%
% \Finale
\endinput
% vim: sw=4 ts=4 noet fdm=marker foldmarker=\\begin,\\end foldcolumn=3
