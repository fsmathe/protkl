% \iffalse
% prot package
% Copyright 2021 Markus Kurtz
%
% If called with nonLaTeX or with \install=y or as a batch file
% generate some nice files.  Otherwise produce documentation.
%<*ignore>
	{\def\x{LaTeX2e}\expandafter}%
	\ifcase0% if \install=y or \processbatchFile is defined or \fmtname=LaTeX2e
		\ifx\install y1\fi
		\expandafter\ifx\csname processbatchFile\endcsname\relax\else1\fi
		\ifx\fmtname\x\else1\fi
	\else\csname fi\endcsname% ... go on after here
%</ignore>
%<*install>
	\input docstrip.tex
	\askforoverwritefalse
	\keepsilent
	\preamble
	This is a prot file.
	\endpreamble
	\generate{
		\file{prot.ins}{\from{prot.dtx}{install}}
		\file{prot.drv}{\from{prot.dtx}{driver}}% for documentation
		\file{prot.sty}{\from{prot.dtx}{package}}
		\file{prot-fsma.def}{\from{style.dtx}{style,fsma}}
		\file{prot-asta.def}{\from{style.dtx}{style,asta}}
		\file{prot-stupa.def}{\from{style.dtx}{style,studischaft,stupa}}
		\file{prot-stupa-ausschuss.def}{\from{style.dtx}{style,studischaft,ausschuss}}
		\file{prot-vv-stud.def}{\from{style.dtx}{style,studischaft,vv}}
		\file{test.lvt}{\from{test.dtx}{test}}
		\file{test.lve}{\from{test.dtx}{expect}}
		\file{prot-t.def}{\from{style.dtx}{style,fsma,studischaft,stupa,test}}
	}
	\endbatchfile
%</install>
%<*ignore>
	\fi % end the \ifcase and produce documentation
%</ignore>
%<*driver>
	\documentclass{l3doc}
	% Allow to write |\cs|
	\MakeShortVerb{\|}
	% Index via codeline
	\CodelineIndex
	\RecordChanges
	\begin{document}
		\DocInput{prot.dtx}
	\end{document}
%</driver>
%
% \fi  end the \iffalse
%
% \title{prot}
% \author{Markus Kurtz}
% \maketitle
% Dieses Paket dient dem Schreiben von Protokollen. Besonders erlaubt es, über die anwesenden Personen, Abstimmungsergebnisse, Aufgaben und Resultate Buch zu führen.
% \section{Layout}
% Wird großteils an \pkg{KoMa-Script} abgegeben.
% Für vorläufige Protokolle (Paket-Option) werden Zeilennummern ausgegeben.
% Lädt \pkg{hyperref} und setzt Titel und Autorin gemäß den Angaben.
% Angaben zu Ort und Zeit der Sitzung werden ebenfalls für Titel im Dokument und in den PDF-Informationen genutzt.
% Am Ende des Protokolls bzw.\@ vor dem Anhang erscheint zudem eine Signatur.
% -- Idee: Angaben zu Ort und Zeit der nächsten Sitzung werden am Ende ausgegeben.
% -- Idee: Es kann eine Begrüßungs- und Abschiedsfloskel ausgegeben werden.
% \section{Personen}
% Zu Beginn des Protokolls werden Personen mit dem Befehl \cmd\prot_newperson:nnnnnn\ angelegt, was typischerweise mittels \cmd\prot_newperson_frontend:nnnnnn\ über \env{personenliste} geschieht.
% Für jede Person legt \cmd\prot_newperson_frontend:nnnnnn\ basierend auf den Argumenten eine ID und den Anzeigenamen fest. Hiermit definiert \cmd\prot_newperson:nnnnnn\ schließlich \cs{\meta{id}} als einfaches Makro, was \meta{name} (und \cmd\xspace) zurückgibt und verarbeitet die restlichen Daten zu Gruppenzugehörigkeit und Anwesenheit.
% Zu Beginn des Dokuments kann dann eine Anwesenheitsliste oder -tabelle ausgegeben werden.
% Später kann dann bei Abstimmungsergebnissen automatisch die Gesamtstimmzahl ermittelt werden und etwa mit |\erg*00| ein einstimmiges Abstimmungsergebnis ausgegeben werden.
% Hierfür ist es natürlich nötig, auch speziell zu notieren, wann stimmberechtigte Personen die Sitzung betreten und verlassen.
% -- Verbesserbar: Implementation von Personen mit mehreren Gruppen
% \section{Textbausteine}
% Der Freundlichkeit halber werden verschiedene Textbausteine etwa für Währungs- und Zeitangaben bereitgestellt sowie für Einschübe für Sitzungspausen oder andere Meta-Informationen.
% Auch nützlich sind die Möglichkeiten, Befehle zu erstellen, die bei erstmaliger Verwendung eine Erklärung bereitstellen.
% -- Idee: Alle Ergebnisse werden in eine ausgelagerte Datei geschrieben und können wahlweise im Protokoll selbst erscheinen oder auch in einem Übersichtsdokument oder sonstwo.
% \StopEventually{\PrintIndex\PrintChanges}
%
% \setcounter{StandardModuleDepth}{1}
%
% \section{Implementation}
%
% Variablen und Konstanten für Person \meta{id} werden unter \cs{\meta{g_|c_|}prot_person->\meta{id}/\meta{var}\meta{_typ|:signatur}} gespeichert.
% Dies erscheint mir ein plausibles Design zu sein, insbesondere unterstützt \LaTeX3 dies nativ mittels |:c|-Argumenten.
%
% \subsection{Dateiköpfe}
%    \begin{macrocode}
%<@@=prot>
%<*package>
	\RequirePackage {expl3} [2021-07-12]
	\ProvidesExplPackage {prot} {2022-03-28} {1.0} {Sitzungsprotokolle}
%    \end{macrocode}
% \subsection{Benötigte Pakete}
%    \begin{macrocode}
	\RequirePackage { l3keys2e }
	\RequirePackage { xspace }
%    \end{macrocode}
% \subsection{Variabel lange Namen}
% \begin{macro}{\NewShortLongText, \ShortLongText}
%   Diese Makros werden in den Styles verwendet. Daher stehen sie hier.
%
%   Beispiel: \cmd\NewShortLongText {ma} [Mathe] {Mathematik}
%   führt zu \cmd\ShortLongText { ma } $\to$ Mathe $\vee$ Mathematik -- je nach Kontext
%    \begin{macrocode}
	\NewDocumentCommand \NewShortLongText { m o m } {
		\tl_const:cn { c_prot_longtext->#1_tl } {#3}
		\IfValueTF {#2}
			{ \tl_const:cn { c_prot_shorttext->#1_tl } {#2} }
			{ \tl_const:cn { c_prot_shorttext->#1_tl } {#3} }
	}
	\bool_new:N \l_prot_shorttext_bool
	\NewDocumentCommand \ShortLongText { m } {
		\tl_use:c {
			c_prot_
			\bool_if:NTF \l_prot_shorttext_bool { short } { long } text
			->#1_tl
		}
	}
%    \end{macrocode}
% \end{macro}
% \subsection{Parsen eines Datums}
% \begin{macro}{\prot_parse_date:NNNn}
%   \cmd\prot_parse_date:NNNn \marg{year_tl} \marg{month_tl} \marg{day_tl} \marg{date}.
%   Parse Datum numerisch gegeben als |D.M.YYYY| oder |YYYY-M-D| und speichere in die angegebenen Token-Listen.
%   Erlaubt Leerraum hier und da. Führende Nullen bei Tag und Monat sind optional.
%    \begin{macrocode}
	\regex_const:Nn \c@@_isodate_regex { \A\ * (\d{4}) \ *\-\ * 0*(\d{1,2}) \ *\-\ * 0*(\d{1,2}) \ *\Z }
	\regex_const:Nn \c@@_classicdate_regex { \A\ * 0*(\d{1,2}) \.\ * 0*(\d{1,2}) \.\ * (\d{4}) \ *\Z }
	\cs_new_protected_nopar:Nn \prot_parse_date:NNNn {
		\regex_extract_once:NnNTF \c@@_isodate_regex {#4} \l_tmpa_seq {
			\seq_pop_left:NN \l_tmpa_seq \l_tmpa_tl
			\seq_pop_left:NN \l_tmpa_seq #1
			\seq_pop_left:NN \l_tmpa_seq #2
			\seq_pop_left:NN \l_tmpa_seq #3
		} {
			\regex_extract_once:NnNTF \c@@_classicdate_regex {#4} \l_tmpa_seq {
				\seq_pop_right:NN \l_tmpa_seq #1
				\seq_pop_right:NN \l_tmpa_seq #2
				\seq_pop_right:NN \l_tmpa_seq #3
			} {
				\msg_error:nnn { prot } { parse / date / wrong } {#4}
			}
		}
	}
%    \end{macrocode}
% \end{macro}
% \subsection{Befehle für Abkürzungen etc.}
% \begin{macro}{\NewCommandWithReplacement, \NewOnetimeCommand, \DeclareDocumentCommand, \DeclareOnetimeCommand, \NewTextMacro, \NewTextMacroWithReplacement, \NewModifiableTextMacroWithReplacement, \NewTextMacroWithParanthesis, \NewTextMacroWithFootnote, \NewTextMacroWithParanthesisAndFootnote}
%   Ein paar Befehle, die sich beim ersten Aufruf selbst ersetzen, sowie mit
%   und ohne \cmd\xspace.
%
%   Die Variante mit optionalen Argumenten in Key-Value-Syntax und optionalem
%   folgenden Bindestrich erlaubt, die Grammatik anzupassen, um beispielsweise
%   |den \asta[r=n]| korrekt schreiben zu können.
%   Genauer ersetzt |\asta[r=n, el][ss=fg]-| im Ersetzungstext (inklusive
%   Klammern) das erste |r| durch ein |n|, ersetzt alle |ss| durch |fg|, hängt
%   ein |el| an und ersetzt dank des |-| alle Leerzeichen durch Bindestriche.
%   Das Ergebnis ist sowas wie |Allgemeinen"=Studierendenaufgufgel"=(AStA)"=|.
%    \begin{macrocode}
	\NewDocumentCommand \NewCommandWithReplacement { m O{} +m +m } { \NewDocumentCommand {#1} {#2} { \RenewDocumentCommand {#1} {#2} {#3} #4 } }
	\NewDocumentCommand \NewOnetimeCommand { m O{} +m } { \NewDocumentCommand {#1} {#2} { \RenewDocumentCommand {#1} {#2} { } #3 } }
	\NewDocumentCommand \DeclareCommandWithReplacement { m O{} +m +m } { \DeclareDocumentCommand {#1} {#2} { \RenewDocumentCommand {#1} {#2} {#3} #4 } }
	\NewDocumentCommand \DeclareOnetimeCommand { m O{} +m } { \DeclareDocumentCommand {#1} {#2} { \RenewDocumentCommand {#1} {#2} { } #3 } }
	\NewDocumentCommand \NewTextMacro { m m } { \newcommand #1 { #2 \xspace } }
	\NewDocumentCommand \NewTextMacroWithReplacement { m O{} m +m } { \NewCommandWithReplacement {#1} [#2] { #3 \xspace } { #4 \xspace } }
	\NewDocumentCommand \NewModifiableTextMacroWithReplacement { m m +m } { \NewCommandWithReplacement {#1} [ O{} O{} t- ] { #2 \xspace } { \prot_tl_replace_kv:nnnn { #3 \xspace } {##1} {##2} {##3} } }
	\NewDocumentCommand \NewTextMacroWithParanthesis { m m +m } { \NewModifiableTextMacroWithReplacement {#1} {#2} { #3 ~ \prot_paren:n {#2} } }
	\NewDocumentCommand \NewTextMacroWithFootnote { m m +m } { \NewTextMacroWithReplacement {#1} {#2} { #2 \footnote {#3} } }
	\NewDocumentCommand \NewTextMacroWithParanthesisAndFootnote { m m m +m } { \NewModifiableTextMacroWithReplacement {#1} {#2} { #3 \footnote {#4} ~ \prot_paren:n {#2} } }
	\cs_new:Nn \prot_paren:n { ( #1 ) }
%    \end{macrocode}
% \end{macro}
% \subsection{Paketoptionen}
% \begin{key}{prot/options}
%   Datum, Uhrzeit etc.\@ können dem Paket (oder auch der Dokumentklasse) übergeben werden.
%   Alternativ funktioniert auch \cmd\sitzungsdaten\ für den selben Zweck.
%
%   Die |style|-Option lädt gremienspezifische Konfiguration nach.
%   Beispieslweise mit |style=fsma|.
%   Laden mehrerer Styles auf eigene Gefahr.
%   Styles, deren Namen aus nur einem Zeichen besteht, stehen nur zu
%   Testzwecken zur Verfügung und werden nicht installiert.
%   Zwecks Abwärtskompatibilität wird der Haken |prot/after| zur Verfügung
%   gestellt, der das gleiche tut, was sonst auch |package/prot/after| tut.
%    \begin{macrocode}
	\NewHook { prot / after }
	\keys_define:nn { prot / options } {
		, style .code:n = { \file_input:n { prot-#1.def } }
		, datum .code:n = { \prot_parse_date:NNNn \l_prot_meeting_year_tl \l_prot_meeting_month_tl \l_prot_meeting_day_tl {#1} }
		, start .tl_set:N = \l_prot_meeting_start_tl
		, ende .tl_set:N = \l_prot_meeting_ende_tl
		, version .tl_set:N = \l_prot_meeting_version_tl
		, forlaeufig .meta:n = { version = #1 }
		, forlaeufig .default:n = 0
		, vorlaeufig .meta:n =  { version = #1 }
		, vorlaeufig .default:n = 1
		, gremium .tl_set:N = \l_prot_meeting_gremium_tl
		, titel .tl_set:N = \l_prot_meeting_titel_tl
		, untertitel .tl_set:N = \l_prot_meeting_untertitel_tl
		, legislatur .tl_set:N = \l_prot_meeting_legislatur_tl
		, sitzung .tl_set:N = \l_prot_meeting_sitzung_tl
		, unterschriftsdatum .code:n = { \prot_parse_date:NNNn \l_prot_unterschrift_year_tl \l_prot_unterschrift_month_tl \l_prot_unterschrift_day_tl {#1} }
		% Optionen
		, nogimmicks .bool_set:N = \l_prot_option_nogimmicks_bool
		, autosignatur .bool_set:N = \l_prot_option_autosignatur_bool
	}
	\cs_new_protected:Npn \sitzungsdaten { \keys_set:nn { prot / options } }

	\tl_new:N \l_prot_meeting_year_tl
	\tl_new:N \l_prot_meeting_month_tl
	\tl_new:N \l_prot_meeting_day_tl
	\tl_new:N \l_prot_unterschrift_year_tl
	\tl_new:N \l_prot_unterschrift_month_tl
	\tl_new:N \l_prot_unterschrift_day_tl

	\ProcessKeysOptions { prot / options }

	\newcommand \sStart { \l_prot_meeting_start_tl \nbsp Uhr \xspace }
	\newcommand \sEnde { \l_prot_meeting_ende_tl \nbsp Uhr \xspace }
	\newcommand \sVersion { \l_prot_meeting_version_tl \xspace }
	\newcommand \Vorlaeufiges { \tl_if_empty:NF \l_prot_meeting_version_tl { \exp_not:n { Vorläufiges~ } } }
	\newcommand \sDatum { \tl_if_empty:NTF \l_prot_meeting_day_tl
		{ \msg_error:nn { prot } { meeting / date / missing } }
		{ \DTMdisplaydate \l_prot_meeting_year_tl \l_prot_meeting_month_tl \l_prot_meeting_day_tl {-1} }
	}
	\newcommand \unterschriftsdatum { \tl_if_empty:NTF \l_prot_unterschrift_day_tl
			{ \today }
			{ \DTMdisplaydate \l_prot_unterschrift_year_tl \l_prot_unterschrift_month_tl \l_prot_unterschrift_day_tl {-1} }
	}
	\newcommand \sGremium { \l_prot_meeting_gremium_tl }
	\newcommand \sTitel { \l_prot_meeting_titel_tl }
	\newcommand \sUntertitel { \l_prot_meeting_untertitel_tl }
	\newcommand \sitzungsteSitzung { \tl_if_empty:NF \l_prot_meeting_sitzung_tl { \l_prot_meeting_sitzung_tl . \nbsp Sitzung } }
	\newcommand \legislaturste { \tl_if_empty:NF \l_prot_meeting_legislatur_tl { \l_prot_meeting_legislatur_tl . \nbsp } }

	\date { \sDatum
		\\ \l_prot_meeting_start_tl \nbsp Uhr~
		--~ \l_prot_meeting_ende_tl \nbsp Uhr
		}
	\author { \protokollfuehrung }
%    \end{macrocode}
% \end{key}
% \subsection{Personentabelle einlesen und ausgeben}
% \subsubsection{Einlesen der Personentabelle}
% \begin{environment}{persontable}
%   Liest gesamte Tabelle ein. Leerzeilen und leerer Inhalt zwischen zwei
%   \cmd\\ werden ignoriert.
%    \begin{macrocode}
	\NewDocumentEnvironment { persontable } { +b } {
		\tl_set:Nn \l_tmpa_tl {#1}
		\tl_remove_all:Nn \l_tmpa_tl { \par }
		\exp_args:NNnV \seq_set_split:Nnn \l@@_persontable_seq { \\ } \l_tmpa_tl
		\seq_remove_all:Nn \l@@_persontable_seq { }
		\seq_map_inline:Nn \l@@_persontable_seq {
			\seq_set_split:Nnn \l@@_personrow_seq & {##1}
			\int_compare:nNnTF { \seq_count:N \l@@_personrow_seq } = 6 {
				\exp_last_unbraced:Nx \prot_newperson_frontend:nnnnnn { \prot_tl_from_seq:N \l@@_personrow_seq }
			} {
				\msg_error:nnxx { prot } { persontable / col-count }
					{ \seq_use:Nn \l@@_personrow_seq { ~\&~ } }
					{ \seq_count:N \l@@_personrow_seq }
			}
		}
	} { }
	\seq_new:N \l@@_persontable_seq
	\seq_new:N \l@@_personrow_seq
%    \end{macrocode}
% \end{environment}
% \subsubsection{Sortieren innerhalb der Gruppen}
% \begin{macro}{\prot_attendance_section_sort:n, \prot_person_seq_sort:N, \prot_set_sortname:Nn, \prot_set_collationclass:Nn, }
%   Die Sequenzen der Gruppen können optional vor der Ausgabe sortiert werden.
%   Zum Sortieren nutzen wir \cmd\prot_set_sortname:Nn \cmd\l_tmpa_tl\marg{id},
%   was \meta{Nachname}~\meta{Vorname} generiert und danach mittels
%   \cmd\prot_set_collationclass:Nn\ den Namen mehr oder weniger gut auf seine
%   Kollationsklasse abbildet. Leerzeichen in den Namen werden natürlich
%   nachrangig nach dem Leerzeichen zwischen Vor- und Nachnamen behandelt.
%    \begin{macrocode}
	\cs_new_protected_nopar:Nn \prot_attendance_section_sort:n {
		\exp_args:Nc \prot_person_seq_sort:N { g_prot_attendance_section_ #1 _seq }
	}
	\cs_new_protected_nopar:Nn \prot_person_seq_sort:N {
		\seq_gsort:Nn #1 {
			\prot_set_sortname:Nn \l_tmpa_tl {##1}
			\prot_set_sortname:Nn \l_tmpb_tl {##2}
			\str_compare:VNVTF \l_tmpa_tl > \l_tmpb_tl
				{ \sort_return_swapped: }
				{ \sort_return_same: }
		}
	}
	\cs_new_protected_nopar:Nn \prot_set_sortname:Nn {
		\exp_args:NNx \prot_set_collationclass:Nn #1 {
			\exp_not:v { c_prot_person -> #2 / name / last_tl }
			\scan_stop: \exp_not:v { c_prot_person -> #2 / name / first_tl }
		}
	}
	\cs_new_nopar:Nn \prot_set_collationclass:Nn {
		\tl_set:Nf #1 { \text_lowercase:n { \exp_stop_f: #2 } }
		\tl_replace_all:Nnn #1 { ä } { ae }
		\tl_replace_all:Nnn #1 { ö } { oe }
		\tl_replace_all:Nnn #1 { ü } { ue }
		\tl_replace_all:Nnn #1 { ß } { ss }
		\tl_replace_all:Nnn #1 { ~ } { ! }
		\tl_replace_once:Nnn #1 { \scan_stop: } { ~ }
	}
%    \end{macrocode}
% \end{macro}
% \subsubsection{Ausgeben der Personentabelle}
% \begin{macro}{\prot_attendancelist:n, \prot_attendancelist_item:nn, \prot_attendancetable:nn, \prot_attendancetable_part:nn}
%   Gibt Anwesenheitsliste aus. Innerhalb von \cmd\prot_attendancelist:n\
%   sollen \cmd\prot_attendancelist_item:nn\ auftauchen (prinzipiell gehen
%   natürlich auch andere Items.  Für die jeweiligen Gruppen geben
%   \cmd\prot_attendancelist_item:nn \marg{Sequenzname} \marg{Anzeigename}
%   den Inhalt von \cs{g_prot_attendance_section_\meta{Sequenzname}_seq} aus
%   und schreiben \meta{Anzeigename} vornedran. Items mit leeren Sequenzen
%   werden übersprungen. Wenn alle Sequenzen leer sein sollten, gibt es eine
%   schlechte Fehlermeldung.
%    \begin{macrocode}
	\cs_new_protected_nopar:Nn \prot_attendancelist:n {
		\begin{description}
			#1
		\end{description}
	}
	\cs_new_protected_nopar:Nn \prot_attendancelist_item:nn {
		\seq_if_empty:cF { g_prot_attendance_section_#1_seq } {
			\seq_set_map_x:Ncn \l_tmpa_seq { g_prot_attendance_section_#1_seq } { \prot_fullnickname:n {##1} \prot_info:n {##1} \prot_specials:n {##1} }
			\exp_args:Nnx \prot_attendancelist_actualitem:nn {#2} { \seq_use:Nn \l_tmpa_seq { ,~ } }
		}
	}
	\cs_new:Nn \prot_attendancelist_actualitem:nn { \exp_not:n { \item[#1] #2 } }
%    \end{macrocode}
%   Gibt Anwesenheitstabelle mit zwei getrennten Spalten aus. Die Gruppen
%   werden ebenso wie oben angegeben. Das Aussehen einer Tabellenzeile wird
%   mittels \cmd\prot_attendancetable_actualentry:n\ festgelegt und kann
%   darüber angepasst werden.
%    \begin{macrocode}
	\bool_new:N \g@@_attendancetable_has_previous_bool
	\dim_new:N \l@@_attendancetable_namewidth_dim
	\cs_new_protected_nopar:Nn \prot_attendancetable:nn {
		\bool_gset_false:N \g@@_attendancetable_has_previous_bool
		\dim_set:Nn \l@@_attendancetable_namewidth_dim {#1}
		\begin{tabular}[t]{cp{#1}}
			\toprule
			% Achtung: Zwischen dem letzten |\\| und |\bottomrule| muss alles expandierbar sein.
			#2
			\bottomrule
		\end{tabular}
	}
	\cs_new_nopar:Nn \prot_attendancetable_part:nn {
		\seq_if_empty:cF { g_prot_attendance_section_#1_seq } {
			\bool_if:NT \g@@_attendancetable_has_previous_bool \midrule
			\multicolumn 2 l { \exp_not:n {#2} } \\
			\midrule
			\bool_gset_true:N \g@@_attendancetable_has_previous_bool
			\seq_map_function:cN { g_prot_attendance_section_#1_seq } \prot_attendancetable_actualentry:n
		}
	}
	\cs_new:Nn \prot_attendancetable_actualentry:n { \prot_table_row:nn { \prot_attendance:n {#1} } { \prot_fullname:n {#1} \prot_info:n {#1} } }
	\cs_new:Nn \prot_table_row:nn {
		#1 & \prot_use_short_long:nn { \l@@_attendancetable_namewidth_dim } {#2} \\
	}
	\cs_new:Nn \prot_use_short_long:nn {
		\hbox_set:Nn \l_tmpa_box {#2}
		\dim_compare:nNnTF { \box_wd:N \l_tmpa_box } > #1
			{ \group_begin: \bool_set_true:N \l_prot_shorttext_bool #2 \group_end: }
			{#2}
	}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\prot_fullname:n, \prot_fullnickname:n, \prot_attendance:n, \prot_info:n, \prot_specials:n}
%   Informationen über Person.
%    \begin{macrocode}
	\cs_new_nopar:Nn \prot_fullname:n {
		\exp_not:v { c_prot_person -> #1 / name / first_tl }
		\space \exp_not:v { c_prot_person -> #1 / name / last_tl }
	}
	\cs_new_nopar:Nn \prot_fullnickname:n {
		\exp_not:v { c_prot_person -> #1 / name / first_tl }
		\tl_if_empty:cF { c_prot_person -> #1 / name / nick_tl } 
		{ ~ \exp_not:n { „ } \exp_not:v { c_prot_person -> #1 / name / nick_tl } \exp_not:n { “ } }
		\space \exp_not:v { c_prot_person -> #1 / name / last_tl }
	}
	\cs_new_nopar:Nn \prot_attendance:n { \exp_not:v { c_prot_person -> #1 / attendance_str } }
	\cs_new_nopar:Nn \prot_info:n {
		\seq_if_empty:cF { g_prot_person -> #1 / info_seq }
			{ ~ ( \seq_use:cn { g_prot_person -> #1 / info_seq } { ,~ } ) }
	}
	\cs_new_nopar:Nn \prot_specials:n {
		\seq_if_empty:cF { g_prot_person -> #1 / specials_seq }
			{ ~ ( \seq_use:cn { g_prot_person -> #1 / specials_seq } { ,~ } ) }
	}
%    \end{macrocode}
% \end{macro}
% \subsubsection{Parsen des Namens}
% \begin{macro}{\prot_newperson_frontend:nnnnnn}
%   Erstellt \meta{id} und \meta{name} mittels \cs{@@_set_idname_via_shorty:nnnn} und verarbeitet Angaben zur Gruppenzugehörigkeit, Anwesenheit und Zusatzinformationen.
%    \begin{macrocode}
	\str_new:N \l@@_id_str
	\tl_new:N \l@@_name_tl
	\tl_new:N \l@@_nickname_tl
	\exp_args_generate:n { VVV }
	\cs_new_protected_nopar:Npn \prot_newperson_frontend:nnnnnn #1#2#3#4 {
		\@@_set_idname_via_shorty:nnnn {#1} {#2} {#3} {#4}
		\exp_args:NVVV \prot_newperson:nnnnnnn \l@@_id_str \l@@_name_tl \l@@_nickname_tl {#2} {#3}
	}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_set_idname_via_shorty:nnnn}
%   Nimmt |id, first, last, shorty|
%   Legt basierend auf dem ersten Argument \marg{shorty} fest, wie der Name abgekürzt werden soll.
%   Dazu nutzt es \pkg{l3str} und \pkg{l3tl}.
%    \begin{macrocode}
	\cs_new_protected_nopar:Nn \@@_set_idname_via_shorty:nnnn {
		\tl_set:Nn \l@@_nickname_tl {}
		\tl_if_blank:nTF {#4} {
			\@@_set_idname:n {#2}
		} {
			\str_set:Nn \l@@_id_str {#2}
			\tl_set:Nn \l@@_name_tl {#2}
			\str_case:onF { \tl_head:w #4 {}\q_stop } {
				{=} { \tl_put_right:Nn \l@@_name_tl { ~ #3 } }
				{?} { \tl_put_right:Nx \l@@_name_tl { ~ \tl_range:nnn {#4} {2} {-1} } }
				{:} { \tl_set:Nx \l@@_name_tl { \tl_range:nnn {#4} {2} {-1} } }
				{!} { \@@_set_abbreviation:x { \tl_range:nne {#3} {1} { \tl_count:n {#4} } } }
			} {
				\@@_set_idname:n {#4}
				\tl_set:Nn \l@@_nickname_tl {#4}
			}
		}
		\tl_if_blank:nF {#1} { \str_set:Nn \l@@_id_str {#1} }
		\str_remove_all:Nn \l@@_id_str {~}
		\str_remove_all:Nn \l@@_id_str {-}
	}
	\cs_new_protected_nopar:Nn \@@_set_idname:n {
		\str_set:Nn \l@@_id_str {#1}
		\tl_set:Nn \l@@_name_tl {#1}
	}
	\cs_new_protected_nopar:Nn \@@_set_abbreviation:n {
		\str_put_right:Nn \l@@_id_str {#1}
		\tl_put_right:Nn \l@@_name_tl { \nbsp #1 . }
	}
	\cs_generate_variant:Nn \@@_set_abbreviation:n { x }
%    \end{macrocode}
% \end{macro}
% \subsubsection{Anlegen einer Person}
% \begin{macro}{\prot_newperson:nnnnnnn}
%   Nimmt \marg{id}, \marg{name}, \marg{first_name}, \marg{last_name}, \marg{group}, \marg{attendance}, \marg{special}, \marg{voter}.
%   Zuvor müssen diese bereits befüllt werden.
%   Dabei werden \marg{id} und \marg{name} von \prot_newperson_frontend:nnnnnn und \marg{group} und \marg{voter} protokollspezifisch festgelegt.
%   \item Der Anzeigename \meta{name} wird anhand des \meta{shortname}-Arguments festgelegt.
%   \item Die \meta{id} wird falls vorhanden und nichtleer durch das \meta{id}-Argument und andernfalls gleich zu \meta{name} festgelegt.
%   Sollte \cs{\meta{id}} bereits definiert sein, wird ein Fehler erzeugt und das Anlegen der Person abgebrochen. Ansonsten wird \cs{\meta{id}} als \meta{name} mit folgendem |\@\xspace| definiert.
%   \NB{Das |\@| sorgt dafür, dass Abstände wie bei einem normalen Wortende (also einem Kleinbuchstaben) gesetzt werden, auch wenn der Name möglicherweise mit einem Punkt oder Großbuchstaben enden sollte.}
%
%   Zuerst wird geschaut, ob die \meta{id} ein Commandstring werden kann und dann in \cs{g@@_names_prop} die \meta{id} hinterlegt bzw\@. gemeckert, falls \meta{name} bereits belegt ist.
%    \begin{macrocode}
	\prop_new:N \g@@_names_prop
	\str_new:N \l@@_samename_id_str
	\cs_new_protected_nopar:Nn\prot_newperson:nnnnnnn {
		\prot_tl_if_alphabetic:nTF {#1} {
			\cs_if_exist:cTF {#1} {
				\cs_if_exist:cTF { c_prot_person -> #1 / id_str }
					{ \msg_error:nnn { prot } { person / id-exists } {#1} }
					{ \msg_error:nnn { prot } { person / id-iscsname } {#1} }
			} {
				\tl_const:cn {#1} { #2\@\xspace }
				\prop_get:NnNTF \g@@_names_prop {#2} \l@@_samename_id_str
					{ \msg_error:nnnnV { prot } { person / name-exists } {#2} {#1} \l@@_samename_id_str }
					{ \prop_gput:Nnn \g@@_names_prop {#2} {#1} }
%    \end{macrocode}
%   Danach werden unter \cs{g_prot_person->\meta{id}/\meta{\dots}} verschiedene Konstanten befüllt:
%   |name_tl|, |name/first_tl|, |name/last_tl|, |attendance_str|, |group_str|.
%    \begin{macrocode}
				\str_set:Nn \l@@_person_str { prot_person -> #1 }
				\str_const:cn { c_\l@@_person_str / id_str } {#1}
				\tl_const:cn { c_\l@@_person_str / name_tl } {#2}
				\tl_const:cn { c_\l@@_person_str / name / nick_tl } {#3}
				\tl_const:cn { c_\l@@_person_str / name / first_tl } {#4}
				\tl_const:cn { c_\l@@_person_str / name / last_tl } {#5}
				\@@_parse_attendance:n {#7}
				\@@_set_attendance:
				\@@_apply_group:n {#6}
				\@@_initialize_move:
				\@@_add_to_attendance_list:vv { g_\l@@_person_str / group_str } { c_\l@@_person_str / attendance_str }
			}
		} { \msg_error:nnn { prot } { person / malformed-id } {#1} }
	}
	\str_new:N \l@@_person_str
%    \end{macrocode}
% \end{macro}
% \subsubsection{Parsen der Anwesenheit}
% \begin{macro}{\@@_parse_attendance:n, \@@_set_attendance:n}
%   Über das Anwesenheitsfeld wird die Anwesenheit als ein Single-Choice-Wert definiert,
%   üblicherweise eins aus: x (anwesend), d (digital), e (entschuldigt), u (unentschuldigt).
%   Zusätzlich können hier noch weitere Attribute festgelegt werden: p (Protokoll), s (Sitzungsleitung)
%   beide setzen den Säumniswert für die Anwesenheit auf „x“ und rufen |\...| auf, was in der Person
%   einen Schalter setzt und die Person in der Liste für Protokoll/Sitzungsleitung einträgt.
%
%   Verschiedene Anwesenheitsmarker können als Schlüssel unter \emph{/prot/attendance/} angelegt werden.
%   Jede Gruppe ist implementiert als Menge an Personen. Zudem ist unter
%   \cs{g_prot_person->\meta{id}/group_str} die primäre Gruppe hinterlegt, wobei spätere Angaben vorherige überschreiben.
%    \begin{macrocode}
	\cs_new_protected_nopar:Nn \@@_parse_attendance:n {
		\seq_new:c { g_\l@@_person_str / specials_seq }
		\keys_set:nn { prot / attendance } { value =, fallback = u, #1 }
		\str_if_empty:NT \l@@_attendance_str { \str_set_eq:NN \l@@_attendance_str \l@@_attendance_fallback_str }
	}
	\cs_new_protected_nopar:Nn \@@_set_attendance: {
		\bool_new:c { g_\l@@_person_str / there_bool }
		\keys_set:nV { prot / attendance / use } \l@@_attendance_str
		\prot_provide:Ncn \tl_const:cv { c_\l@@_person_str / attendance / disp_tl } { c_\l@@_person_str / attendance_str }
	}
	\str_new:N \l@@_attendance_str
	\str_new:N \l@@_attendance_fallback_str
	\keys_define:nn { prot / attendance } {
		, value .code:n = { \str_set:Nn \l@@_attendance_str {#1} }
		, fallback .code:n = { \str_set:Nn \l@@_attendance_fallback_str {#1} }
		, attendance .code:n = { \str_const:cn { c_ \l@@_person_str / attendance_str } {#1} }
		, attendance / disp .code:n = { \tl_const:cn { c_ \l@@_person_str / attendance / disp_tl } { \exp_not:n{#1} } }
		% Koennte auch direkt ein bool sein
		, there .code:n = { \bool_gset:cn { g_ \l@@_person_str / there_bool } { \int_compare_p:nNn {#1} > 0 } }
		, protokoll .code:n = { \seq_gput_right:NV \g_prot_protokollfuehrung_seq \l@@_id_str }
		, sitzungsleitung .code:n = { \seq_gput_right:NV \g_prot_sitzungsfuehrung_seq \l@@_id_str }
		, x .meta:n = { value = x }, use / x .meta:n = { attendance = x, there = 1 }
		, e .meta:n = { value = e }, use / e .meta:n = { attendance = e, there = 0 }
		, u .meta:n = { value = u }, use / u .meta:n = { attendance = u, there = 0 }
		, d .meta:n = { value = d }, use / d .meta:n = { attendance = d, there = 1, attendance / disp = \emph x }
		, p .meta:n = { fallback = x, special = Protokoll, protokoll }
		, s .meta:n = { fallback = x, special = Sitzungsleitung, sitzungsleitung }
	}

%    \end{macrocode}
% \end{macro}
% \subsubsection{Parsen der Gruppenzugehörigkeit}
% \begin{macro}{\@@_apply_group:n}
%    \begin{macrocode}
	\cs_new_protected_nopar:Nn \@@_apply_group:n {
		\str_new:c { g_\l@@_person_str / group_str }
		\seq_new:c { g_\l@@_person_str / info_seq }
		\keys_set_known:nn { prot / group } {#1}
		\prot_provide:Ncn \cs_new_protected_nopar:cn { \l@@_person_str / aftermove:N } { }
		\tl_if_empty:cT { g_\l@@_person_str / group_str } { \keys_set:nn { prot / group } { g } }
	}
	\keys_define:nn { prot / group } {
		, voter .code:n = { \cs_new_protected_nopar:cpn { \l@@_person_str / aftermove:N } { \@@_move_voter:N } }
		, groupvoter .code:n = { \@@_make_groupvoter:Vn \l@@_id_str {#1} }
		, group .code:n = {
			\str_gset:cn { g_ \l@@_person_str / group_str } {#1}
			\seq_gput_right:cV { g_prot_group_#1_seq } \l@@_id_str
		}
		, votergroup .meta:n = { group = #1, groupvoter = #1 }
		, info .code:n = { \tl_if_empty:nF {#1} { \seq_gput_right:cn { g_ \l@@_person_str / info_seq } {#1} } }
		, voter      .value_forbidden:n = true
		, groupvoter .value_required:n = true
		, group      .value_required:n = true
		, votergroup .value_required:n = true
		, info       .value_required:n = true
		, g .meta:n = { group = g, info = {#1} }
	}
	\cs_generate_variant:Nn \keys_define:nn { nx }
	\seq_new:N \g_prot_group_g_seq

	\int_new:N \g_prot_voters_int
	\cs_new_protected_nopar:Nn \@@_move_voter:N {
		\bool_if:NTF {#1}
			{ \int_gincr:N \g_prot_voters_int }
			{ \int_gdecr:N \g_prot_voters_int }
	}
	\cs_new_protected_nopar:Nn \@@_make_groupvoter:nn {
		\cs_new_protected_nopar:cpn { prot_person ->  #1 / aftermove:N } { \@@_move_groupvoter:nnN {#1} {#2} }
	}
	\cs_generate_variant:Nn \@@_make_groupvoter:nn { Vn }
	\cs_new_protected_nopar:Nn \@@_move_groupvoter:nnN {
		\bool_if:NTF #3
			\@@_enter_groupvoter:cn
			\@@_leave_groupvoter:cn
		{ g_prot_votergroup_#2_seq } {#1}
	}
	\cs_new_protected_nopar:Nn \@@_leave_groupvoter:Nn {
		\seq_if_in:NnTF #1 {#2} {
			\seq_gremove_all:Nn #1 {#2}
			\seq_if_empty:NT #1 {
				\int_gdecr:N \g_prot_voters_int
			}
		} {
			\msg_warning:nnn { prot } { move / wrong-groupvoter } {#2}
		}
	}
	\cs_new_protected_nopar:Nn \@@_enter_groupvoter:Nn {
		\seq_if_in:NnTF #1 {#2} {
			\msg_warning:nnn { prot } { move / wrong-groupvoter } {#2}
		} {
			\seq_if_empty:NT #1 {
				\int_gincr:N \g_prot_voters_int
			}
			\seq_gput_right:Nn #1 {#2}
		}
	}
	\cs_generate_variant:Nn \@@_leave_groupvoter:Nn { c }
	\cs_generate_variant:Nn \@@_enter_groupvoter:Nn { c }
%    \end{macrocode}
%   For tests see at the very end.
% \end{macro}
% \subsubsection{Einordnen in Anwesenheitsliste mittels Gruppe und Anwesenheit}
% \begin{macro}{\@@_add_to_attendance_list:vv, \prot_add_attendance_section:n, \prot_add_x_attendance_section:n}
%   Nach Parsen der Personendaten führt \cmd\prot_newperson:nnnnnn\ schließlich
%   \cmd\@@_add_to_attendance_list:vv\marg{gruppe}\marg{anwesenheit} aus,
%   beispielsweise |\@@_add_to_attendance_list:vv{g}{x}|.  Dies wiederum ruft
%   Schlüssel definiert durch \cmd\prot_add_attendance_section:n\ und
%   \cmd\prot_add_x_attendance_section:n\ auf.  Ersteres packt die Person zu
%   der zur entsprechendne Gruppe gehörigen Sequenz (beispielsweise
%   \cmd\g_prot_attendance_section_g_seq) hinzu und zweiteres nur, wenn die
%   Anwesenheit |x| lautet.
%    \begin{macrocode}
	\cs_new_protected_nopar:Nn \@@_add_to_attendance_list:nn {
		\keys_set:nn { prot / attendance_list } { #1 = #2 }
	}
	\cs_generate_variant:Nn \@@_add_to_attendance_list:nn { vv }

	\cs_new_protected:Nn \prot_add_attendance_section:n {
		\seq_new:c { g_prot_attendance_section_#1_seq }
		\keys_define:nn { prot / attendance_list } {
			#1 .code:n = \seq_gput_right:cV { g_prot_attendance_section_#1_seq } \l@@_id_str
		}
	}
	\cs_new_protected:Nn \prot_add_x_attendance_section:n {
		\seq_new:c { g_prot_attendance_section_#1_seq }
		\keys_define:nn { prot / attendance_list } {
			#1 .code:n = \str_if_eq:nnT {##1} { x } { \seq_gput_right:cV { g_prot_attendance_section_#1_seq } \l@@_id_str }
		}
	}
	\prot_add_x_attendance_section:n { g }
%    \end{macrocode}
% \end{macro}
% \subsubsection{Kleinkram}
% \begin{key}{attendance/special, group/special}
%   Durch den |special|-Schlüssel gesetzte Informationen werden mit \cmd\prot_specials:n ausgegeben, um beispielsweise in einer Anwesenheitsliste in Klammern aufzutauchen.
%    \begin{macrocode}
	\keys_define:nn { prot } {
		, attendance / special .code:n = { \seq_gput_right:cn { g_ \l@@_person_str / specials_seq } {#1} }
		, group / special .code:n = { \seq_gput_right:cn { g_ \l@@_person_str / specials_seq } {#1} }
	}
%    \end{macrocode}
% \end{key}
% \begin{macro}{\sitzungsfuehrung, \protokollfuehrung}
%   Die Befehle \cmd\sitzungsfuehrung und \cmd\protokollfuehrung geben die entsprechenden Personen (ggf. kommasepariert) aus.
%   Beachte, dass \cmd\protokollfuehrung expandierbar sein muss, um in \cmd\hypersetup genutzt werden zu können.
%    \begin{macrocode}
	\seq_new:N \g_prot_sitzungsfuehrung_seq
	\seq_new:N \g_prot_protokollfuehrung_seq

	\NewExpandableDocumentCommand \sitzungsfuehrung { } {
		\seq_if_empty:NTF \g_prot_sitzungsfuehrung_seq {
			\msg_error:nn { prot } { person / no-leader }
		} {
			\prot_tl_use:en { \seq_map_function:NN \g_prot_sitzungsfuehrung_seq \@@_fullname_aux:n } { ,~ }
		}
	}
	\NewExpandableDocumentCommand \protokollfuehrung { } {
		\seq_if_empty:NTF \g_prot_protokollfuehrung_seq {
			\msg_error:nn { prot } { person / no-record }
		} {
			\prot_tl_use:en { \seq_map_function:NN \g_prot_protokollfuehrung_seq \@@_fullname_aux:n } { ,~ }
		}
	}
	\cs_new_nopar:Nn \@@_fullname_aux:n { { \prot_fullname:n {#1} } }
%    \end{macrocode}
% \end{macro}
% \subsection{Personenbewegungen}
% \begin{macro}{\prot_move:Nn, \@@_initialize_move:}
%   Momentane Implementierung: Alle Menschen kommen automatisch, wenn sie mit |x| oder dergleichen angelegt sind.
%   Beim Einlesen der |.aux|-Datei gehen alle, deren erste Interaktion ein Kommen ist.
%   Bei allen späteren Bewegungen prüfe, ob dies die erste Bewegung ist und falls diese ein Kommen ist, schreibe in die |.aux|-Datei ein (nicht als erste Bewegung zählendes Gehen (siehe vorheriger Punkt)).
%   Bei einer nicht-ersten Bewegung hingegen verifiziere, dass diese das Gegenteil der vorherigen Anwesenheit ist.
%
%   \cs{prot_move:Nn} setzt momentane Anwesenheit \cs{g_prot_person->#2/there_bool} von #2=\meta{id} auf |#1|.
%   Schaut in \cs{g_prot_person->#2/moves_tl} nach,
%   ob die Person sich nicht bewegen darf (nicht da ist) (kodiert als „-“),
%   ob sie sich noch nicht bewegt hat (kodiert als „0“) – und schreibt dann in die |.aux|-Datei – oder
%   ob sie sich bereits bewegt hat (kodiert als „+“) und prüft dann auf Konsistenz.
%   Nutzt |forcemove| ohne Tests und für personenabhängige Zwecke, was zusätzlich \cs{prot_person->#2/aftermove:N} aufruft.
%    \begin{macrocode}
	\cs_new_protected_nopar:Nn \prot_move:Nn {
		\exp_args:Nv \str_case:nnF { g_prot_person -> #2 / moves_tl } {
			- { \msg_error:nnn { prot } { move / not-there } {#2} }
			0 {
				\tl_gset:cn { g_prot_person -> #2 / moves_tl } {+}
				\bool_if:NT #1 { \@@_addlate:n {#2} }
				\@@_forcemove:Nn #1 {#2}
			}
		} {
			\bool_xor:nnTF { \bool_if_p:c { g_prot_person -> #2 / there_bool } } {#1} {
				\@@_forcemove:Nn #1 {#2}
			} { \exp_args:Nnx \msg_error:nnn { prot } { move / \bool_to_str:n {#1} - again } {#2} }
		}
	}
	\cs_new_protected_nopar:Nn \@@_initialize_move: {
		\tl_new:c { g_\l@@_person_str / moves_tl }
		\bool_if:cTF { g_\l@@_person_str / there_bool } {
			\tl_gset:cn { g_\l@@_person_str / moves_tl } 0
			\use:c { \l@@_person_str / aftermove:N } \c_true_bool
		} { \tl_gset:cn { g_\l@@_person_str / moves_tl } - }
	}
	\cs_new_protected_nopar:Nn \@@_forcemove:Nn {
		\bool_gset_eq:cN { g_prot_person -> #2 / there_bool } #1
		\use:c { prot_person -> #2 / aftermove:N } #1
	}
	\cs_new_protected_nopar:Nn \@@_addlate:n {
		\iow_now:Nn \@mainaux { \prot@makelate {#1} }
	}
	\cs_new_protected_nopar:Nn \@@_makelate:n { \@@_forcemove:Nn \c_false_bool {#1} }
	% Beim Einlesen der aux-Datei ist keine expl3-Syntax aktiviert, daher hier ein Alias:
	\cs_new_eq:cN { prot@makelate } \@@_makelate:n
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\peoplemove, \peopleenter, \peopleleave, ...text}
%   \cmd\peoplemove\arg{\cs a\cs b\cs c}\arg{\cs x\cs y\cs z} lässt die Personen |a|, |b| und |c| kommen und |x|, |y|, |z| gehen.
%   \cmd\peoplemovetext produziert einen Text im Input-Stream, der beispielsweise in einen \cmd\einschub eingebettet werden kann.
%   \cmd{\peopleenter} und \cmd{\peopleleave} lassen einfach eins der beiden Argumente leer.
%    \begin{macrocode}
	\cs_new_nopar:Npn \peopleenter { \prot_multimove:Nn \c_true_bool }
	\cs_new_nopar:Npn \peopleleave { \prot_multimove:Nn \c_false_bool }
	\cs_new_nopar:Npn \peoplemove #1 #2 { \peopleenter {#1} \peopleleave {#2} }
	\cs_new_nopar:Nn \prot_move:NN { \exp_args:NNe \prot_move:Nn #1 { \cs_to_str:N #2 } }
	\cs_new_nopar:Nn \prot_multimove:Nn { \tl_map_tokens:nn {#2} { \prot_move:NN #1 } }
	\cs_new_nopar:Npn \peopleentertext #1 { \prot_tl_use_german:n {#1} ~ \prot_enter_german:n {#1} ~die~Sitzung. }
	\cs_new_nopar:Npn \peopleleavetext #1 { \prot_tl_use_german:n {#1} ~ \prot_leave_german:n {#1} ~die~Sitzung. }
	\cs_new_nopar:Npn \peoplemovetext #1 #2 { \prot_tl_use_german:n {#1} ~ \prot_enter_german:n {#1} ~und~ \prot_tl_use_german:n {#2} ~ \prot_leave_german:n {#2} ~die~Sitzung. }
	\cs_new_nopar:Nn \prot_enter_german:n { \tl_if_single:nTF {#1} { \exp_not:n {betritt} } { \exp_not:n {betreten} } }
	\cs_new_nopar:Nn \prot_leave_german:n { \tl_if_single:nTF {#1} { \exp_not:n {verlässt} } { \exp_not:n {verlassen} } }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\kommt, \geht, \kommtgeht, \kommtstill, \gehtstill, \kommtgehtstill}
%   \cmd\kommtgeht\arg{\cs a\cs b\cs c}\arg{\cs x\cs y\cs z} lässt die Personen |a|, |b| und |c| kommen und |x|, |y|, |z| gehen.
%   und produziert einen Einschub im Input-Stream.
%   \cmd{\kommt} und \cmd{\geht} lassen einfach eins der beiden Argumente leer.
%   Die Varianten mit |still| am Ende produzieren keinen Text.
%    \begin{macrocode}
	\NewDocumentCommand \kommt { o m } {
		\peopleenter {#2}
		\einschub [#1] { \peopleentertext {#2} }
	}
	\NewDocumentCommand \geht { o m } {
		\peopleleave {#2}
		\einschub [#1] { \peopleleavetext {#2} }
	}
	\NewDocumentCommand \kommtgeht { o m m } {
		\peoplemove {#2} {#3}
		\einschub [#1] { \peoplemovetext {#2} {#3} }
	}
	\cs_new_eq:NN \kommtstill     \peopleenter
	\cs_new_eq:NN \gehtstill      \peopleleave
	\cs_new_eq:NN \kommtgehtstill \peoplemove
%    \end{macrocode}
% \end{macro}
% \subsection{Abstimmungen}
% \begin{macro}{\prot_voting:n, \prot_simple_voting:n}
%   Nimmt eine tokenlist als Argument und lässt ein Ergebnis im Input Stream.
%   \cs{prot_simple_voting:n} tut dies direkt, wohingegen \cs{prot_voting:n} noch etwas mehr erledigt:`
%   Enthält die tokenlist nur Zahlen, gebe das Ergebnis aus und überprüfe zudem, ob die Summe der Zahlen gleich der momentanen Anzahl Stimmberechtigter ist.
%   Enthält die tokenlist einen Stern und sonst nur Zahlen, so ersetze den Stern so durch eine Zahl, dass die Summe wie im vorigen Satz passt.
%   In allen anderen Fällen gibt es einen Fehler.
%    \begin{macrocode}
	\NewDocumentCommand \erg { m m m } { \prot_voting:n { {#1} {#2} {#3} } }
	\NewDocumentCommand \Erg { m m m } { \prot_simple_voting:n { {#1} {#2} {#3} } }
	\NewDocumentCommand \janein { m m } { \prot_voting:n { {#1} {#2} } }
	\NewDocumentCommand \Janein { m m } { \prot_simple_voting:n { {#1} {#2} } }
	\int_new:N \l@@_votes_int
	\int_new:N \l@@_votes_stars_int
	\seq_new:N \l@@_result_seq
	\tl_const:Nn \c_prot_vote_sep_tl { \exp_not:n { \, / \, } }
	\cs_new_protected_nopar:Nn \prot_voting:n {
		\int_zero:N \l@@_votes_int
		\int_zero:N \l@@_votes_stars_int
		\seq_clear:N \l@@_result_seq
		\tl_map_inline:nn {#1} {
			\str_if_eq:nnTF {##1} * {
				\int_incr:N \l@@_votes_stars_int
				\seq_put_right:Nn \l@@_result_seq { \int_eval:n { \g_prot_voters_int - \l@@_votes_int } }
			} {
				\int_add:Nn \l@@_votes_int {##1}
				\seq_put_right:Nn \l@@_result_seq {##1}
			}
		}
		\bool_if:nT {
			\int_compare_p:nNn \l@@_votes_stars_int = 0
			&& ! \int_compare_p:nNn \l@@_votes_int = \g_prot_voters_int
		} {
			\msg_warning:nnxxx { prot } { voting / wrong-count }
				{ \seq_use:Nn \l@@_result_seq + }
				{ \int_use:N \l@@_votes_int }
				{ \int_use:N \g_prot_voters_int }
		}
		\int_compare:nNnTF \l@@_votes_stars_int < 2
			{ \@@_simple_seq_voting:N \l@@_result_seq }
			{ \msg_error:nnn { prot } { voting / super-stars } {#1} }
	}
	\cs_new_nopar:Nn \@@_simple_seq_voting:N { ( \seq_use:Nn #1 \c_prot_vote_sep_tl ) }
	\cs_new_nopar:Nn \prot_simple_voting:n { ( \prot_tl_use:nn {#1} \c_prot_vote_sep_tl ) }
%    \end{macrocode}
% \end{macro}
% \section{Code für weitere Gimmicks}
%   Die Gimmicks sind alle optional. Ich habe mal darauf verzichtet, sie alle einzurücken.
%    \begin{macrocode}
	\bool_if:NF \l_prot_option_nogimmicks_bool {
%    \end{macrocode}
% \subsection{Weitere Pakete}
%    \begin{macrocode}
	\RequirePackage { tabularx }
	\RequirePackage [ useregional ] { datetime2 }
	\RequirePackage [ mode = match, output-decimal-marker = {,} ] { siunitx }
	\RequirePackage { hyperref }
%    \end{macrocode}
% \subsection{PDF-Metadaten}
%   Die Makros werden in \cmd\hypersetup\ expandiert, daher erst verzögert, nach Einlesen der Personentabelle.
%    \begin{macrocode}
	\AtBeginDocument {
		\hypersetup {
			, pdftitle = \@title \tl_if_empty:NF \l_prot_meeting_sitzung_tl { :~ \l_prot_meeting_sitzung_tl.~Sitzung } ~am~ \sDatum
			, pdfsubject = \Vorlaeufiges Sitzungsprotokoll
			, pdfauthor = \protokollfuehrung
		}
	}
%    \end{macrocode}
% \subsection{Abschnitte}
% \begin{macro}{\section, \subsection, \subsubsection}
%   Schreibe „TOP“ vor jeden TOP.
%   Der erste Teil nimmt KOMA-Script an und der zweite Teil nimmt hyperref an.
%    \begin{macrocode}
	\AddToHook { cmd / @seccntformat / before } { TOP~ }
	\AddToHook { cmd / appendix / after } {
		\RemoveFromHook { cmd / @seccntformat / before } [prot]
	}
	\AddToHook { begindocument } {
		\cs_set_nopar:Npn \sectionautorefname { TOP }
		\cs_set_nopar:Npn \subsectionautorefname { TOP }
		\cs_set_nopar:Npn \subsubsectionautorefname { TOP }
	}
%    \end{macrocode}
%   Aktiviere Optionenliste aus KOMA-Script als optionales Argument in \cmd\secion\ et al.
%   Füge außerdem Optionen |marginref| und |marginlink| für Randverweise
%   mittels \cmd\marginref\ und \cmd\marginlink\ hinzu.
%    \begin{macrocode}
	\KOMAoptions { headings = optiontotocandhead }
	\DefineFamilyKey [ .section ] { KOMAarg } { marginlink } {
		\AddtoOneTimeDoHook { heading / endgroup } { \marginlink {#1} \use_none:n }
	}
	\DefineFamilyKey [ .section ] { KOMAarg } { marginref } {
		\AddtoOneTimeDoHook { heading / endgroup } { \marginref {#1} \use_none:n }
	}
%    \end{macrocode}
% \end{macro}
% \subsection{Inhaltsverzeichnis}
% \begin{macro}{\tableofcontents}
%   Trenne Inhaltsverzeichnis in Tagesordnung und Anhang.
%   Da typischerweise eher wenige Unter-TOPs auftauchen, verzichte lieber auf
%   die gepunktete Linie zwischen Namen und Seitenzahl.
%   Trickse mit Punkten nach Gliederungsnummer/-buchstabe herum, vermutlich
%   könnte man auch einfach immer einen Punkt setzen. Wenn jedoch in manchen
%   Protokollen (mit Anhängen) ein Punkt nach „TOP x“ erscheint und in anderen
%   nicht, wirkt dies inkonsistent.
%    \begin{macrocode}
	\AddToHook { begindocument } { \cs_set_nopar:Npn \contentsname { Tagesordnung } }
	\DeclareTOCStyleEntries [ linefill = \hfill ] { tocline } { section , subsection , subsubsection }
	\KOMAoptions { numbers = noenddot }
	\AddToHook { cmd / appendix / after } {
		\cs_set_eq:NN \appendixtoc \scan_stop:
		\addtocontents { toc } { \appendixtoc }
		\cs_set_nopar:Npn \autodot { . }
	}
	\cs_new:Npn \appendixtoc {
		\tocbasic@listhead { Anhang }
		\cs_set_nopar:Npn \autodot { . }
	}
	\AddToHook { cmd / tableofcontents / after } {
		\cs_set_eq:NN \autodot \prg_do_nothing:
	}
%    \end{macrocode}
%   Unterdrücke Fußnoten im Inhaltsverzeichnis, wenn sie in Überschriften
%   auftauchen sollten. Ob in Überschriften überhaupt Fußnoten stehen sollen,
%   ist natürlich eine andere Frage.
%    \begin{macrocode}
	\AddToHook { cmd / tableofcontents / before } {
		\cs_new_eq:NN \@@_footnote:n \footnote
		\cs_set_eq:NN \footnote \use_none:n
	}
	\AddToHook { cmd / tableofcontents / after } {
		\cs_set_eq:NN \footnote \@@_footnote:n
	}
%    \end{macrocode}
% \end{macro}
% \subsection{Vorläufige Protokolle}
% \begin{macro}{\linenumbers, \todo, \change, \del}
%    \begin{macrocode}
	\tl_if_empty:NTF \l_prot_meeting_version_tl {
		%% fertig
		\NewDocumentCommand \todo { m } {
			\PackageError { prot } { TODO:~#1 } { Du~hast~offenbar~noch~irgendetwas~zu~tun. }
		}
		\NewDocumentCommand \change { m } { #1 }
		\NewDocumentCommand \del { m } { }
		\providecommand \linenumbers { }
		\providecommand \nolinenumbers { }
	} {
		%% vorläufig
		\RequirePackage { xcolor }
		\RequirePackage { soulutf8 } % Durchstreichungen -- nicht so prima Paket

		\NewDocumentCommand \todo { m } {
			\PackageWarning { prot } { TODO:~#1 }
			\hl { TODO:~#1 }
		}
		\NewDocumentCommand \change { } { \textcolor {red} }
		\NewDocumentCommand \del { m } { \textcolor {red} { \st {#1} } }

		\RequirePackage { lineno }
		\definecolor { gray }  { gray }  { 0.5 }
		\renewcommand \linenumberfont { \normalfont \tiny \sffamily \textcolor { gray } }
	}
%    \end{macrocode}
% \end{macro}
% \subsection{Textbausteine}
% \begin{macro}{\einschub, \pause, \Pause}
%   Einschübe sind bestimmt praktisch.
%    \begin{macrocode}
	\newkomafont { einschub } { \itshape }
	\NewDocumentCommand \einschub { o o m } {
		\begin{quotation} \noindent
			\usekomafont { einschub }
			\IfValueT {#1} { #1 \IfValueT {#2} { ~--~ #2 } ~Uhr:~ } #3
		\end{quotation}
	}
	\NewDocumentCommand \pause { m m } { \einschub [#1] [#2] { Sitzungspause } }
	\def \Pause #1#2#3#4-#5#6#7#8 { \einschub [ #1#2:#3#4 ] [ #5#6:#7#8 ] { Sitzungspause } }
	\NewDocumentCommand \abstimmungsformateinschub { } { \einschub {
		Abstimmungsergebnisse~werden~als~
		(ja \,/\hspace{.16667em} nein \,/\hspace{.16667em} Enthaltungen) ~
		angegeben.
	} }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\eur, \datum, \quot, \mail}
%    \begin{macrocode}
	\DeclareSIUnit { \eur } { \text { € } }
	\DeclareSIUnit { \ct } { \text { ct } }
	\NewDocumentCommand \eur { m } { \qty {#1} \eur }
	\NewDocumentCommand \ct { m } { \qty {#1} \ct }
	\NewDocumentCommand \quot { m } { „#1“ }
	\NewDocumentCommand \mail { m } { \texttt { \href { mailto:#1 } {#1} } }
	% vier seltsam benannte Datumsbefehle, ich empfehle ja einen der ersten beiden
	\def \datum #1#2#3#4#5#6 { \group_begin: \DTMsetstyle {german} \DTMdisplaydate { 20#5#6 } { #3#4 } { #1#2 } {-1} \group_end: }
	\def \dtm #1#2#3#4 { \int_compare:nNnF #1=0 #1 #2 .~ \DTMgermanmonthname { #3#4 } }
	\def \dat #1#2#3#4#5#6 { \group_begin: \DTMsetstyle { dmyyyy } \DTMsetup { datesep = . } \DTMdisplaydate { 20#5#6 } { #3#4 } { #1#2 } {-1} \group_end: }
	\def \dt #1#2#3#4 { \int_compare:nNnF #1=0 #1 #2 . \int_compare:nNnF #3=0 #3 #4. }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\finanzantrag}
%   Finanzantrag mit \cmd\finanzantrag\oarg{Optionen für \cmd\paragraph}
%   \marg{Finanzantragsnummer} \marg{Finanzantragsname} als \cmd\paragraph
%   darstellen.
%    \begin{macrocode}
	\NewDocumentCommand \finanzantrag { o m m } {
		\IfNoValueTF {#1} { \paragraph } { \paragraph [#1] }
		{ FA\IfValueT{#2}{~#2} \hspace{.5em} \mdseries #3 }
	}

%    \end{macrocode}
% \end{macro}
% \subsubsection{Signatur}
% \begin{macro}{signatur, \ProtokollSignatur, \MakeProtokollSignatur}
%   Setze Signatur am Ende des Dokuments bzw. vor Anhang.
%    \begin{macrocode}
	\NewDocumentEnvironment { signatur } { o m b } {
		\begin {figure} [b]
			\IfNoValueTF {#1} { Kaiserslautern,~ \unterschriftsdatum } {#1}
			\vspace { 12.5 mm } \par
			\begin {tabularx} {\linewidth} { @{} #2 @{} }
				#3
			\end {tabularx}
		\end {figure}
	} {
	}
	\NewDocumentCommand \ProtokollSignatur { o } {
		\begin {signatur} [#1] { X X }
			\protokollfuehrung & \sitzungsfuehrung \\
			Protokoll          & Sitzungsleitung
		\end {signatur}
	}
	\NewOnetimeCommand \MakeProtokollSignatur { \ProtokollSignatur }
	\bool_if:NT \l_prot_option_autosignatur_bool {
		\AddToHook { cmd / appendix /before } { \MakeProtokollSignatur \clearpage }
		\AddToHook { enddocument } { \MakeProtokollSignatur }
	}
%    \end{macrocode}
% \end{macro}
% \subsubsection{PDF-Anhänge}
% \begin{macro}{\IncludePdfSection, \includepdfsection, \includepdfsubsection, \includepdfsubsubsection}
%   Überschrift erscheint ganz oben links auf der Seite.
%   Alternativ auch möglich wäre die Anhänge runterzuskalieren, die
%   Seitenzahlen beizubehalten und den Buchstaben des Anhangs als Randnotiz
%   anzumerken.
%
%   |\IncludePdfSection{sectiontype}{sectionlevel}[options to includepdf][pagenumber]{labelname}{heading}{filename}|
%   Die |pagenumber| sollte die erste eingebundene Seite sein. Bei |pages=2-|
%   also |2|, im Normalfall aber |1|.
%   |\prot_section_topleft_picture:nnn {sectiontype} {labelname} {heading}|
%   setzt innerhalb einer picturecommand-Option oben links auf der Seite mit
%   1em Abstand zum Rand eine Überschrift der Ebene sectiontype, wobei die
%   Nummerierung mittels einer Referenz auf labelname erzeugt wird.
%    \begin{macrocode}
	\RequirePackage { pdfpages }
	\NewDocumentCommand \IncludePdfSection { m m O{} O{1} m m m } {
		\nolinenumbers
		\includepdf [
			, pages = - , link , linkname = #5 , addtotoc = { #4, #1, #2, #6, #5 }
			, picturecommand* = \prot_section_topleft_picture:nnn {#1} {#5} {#6}
			, #3
		] {#7}
		\linenumbers
	}
	\cs_new_protected:Nn \prot_section_topleft_picture:nnn {
		\put ( \dim_to_decimal:n { 1 em } , \dim_to_decimal:n { \paperheight - 2 em } ) {
			\usekomafont { disposition } \usekomafont {#1} \autoref* {#2} \autodot \  #3
		}
	}
	\NewDocumentCommand \includepdfsection { } { \IncludePdfSection { section } { 1 } }
	\NewDocumentCommand \includepdfsubsection { } { \IncludePdfSection { subsection } { 2 } }
	\NewDocumentCommand \includepdfsubsubsection { } { \IncludePdfSection { subsubsection } { 3 } }
%    \end{macrocode}
% \end{macro}
% \subsubsection{Verweise}
% \begin{macro}{\marginref, \marginlink, \autoref}
%   Verweis auf einen Anhang als Randnotiz.
%    \begin{macrocode}
	\NewDocumentCommand \marginref { m } { \marginline { \textsf { \ref {#1} } } }
	\cs_new_protected_nopar:Nn \prot_marginlink:n { \marginline { \hyperlink { #1 . 1 } { \textsf { \ref* {#1} } } } }
	\cs_new_protected_nopar:Nn \prot_marginlink:nn { \marginline { \hyperlink { #1 . #2 } { \textsf{ \ref* {#1} ~ } #2 } } }
	\NewDocumentCommand \marginlink { > { \SplitArgument { 1 } { | } } m } {
		\@@_marginlink_aux:nn #1
	}
	\cs_new_protected_nopar:Nn \@@_marginlink_aux:nn {
		\IfNoValueTF {#2}
			{ \prot_marginlink:n {#1} }
			{ \prot_marginlink:nn {#1} {#2} }
	}
%    \end{macrocode}
%   Autoref schreibt normalerweise nach \cmd\appendix\ automatisch
%   \cmd\appendixautorefname statt \cmd\sectionautorefname für \cmd\section s.
%   Für Unterabschnitte jedoch nicht.  Unterabschnitte in Anhängen würden damit
%   weiterhin als „TOP“ tituliert, was wir nicht wollen.  Entsprechend hacken
%   wir uns das ein wenig zusammen.  Im Endeffekt sorgen wir dafür, dass im
%   \cmd\newlabel-Eintrag in der |.aux|-Datei |appendix.A.1| statt
%   |subsection.A.1| steht.
%    \begin{macrocode}
	\AddToHook { cmd / hyper@makecurrent / after } {
		\ifHy@localanchorname
			\str_replace_once:Nnn \@currentHref { subsubsection } { appendix }
			\str_replace_once:Nnn \@currentHref { subsection } { appendix }
		\else:
			\str_greplace_once:Nnn \@currentHref { subsubsection } { appendix }
			\str_greplace_once:Nnn \@currentHref { subsection } { appendix }
		\fi:
	}
%    \end{macrocode}
% \end{macro}
%   Das Ende der optionalen Gimmicks naht:
%    \begin{macrocode}
	}
%    \end{macrocode}
% \section{Zusätzliche Kernel-Funktionen}
% Ein paar Funktionen und Varianten ohne Bezug zu Protokollen.
% \begin{macro}{\prot_tl_from_seq:N}
%    \begin{macrocode}
	\cs_new:Nn \@@_exp_not_braced:n { \exp_not:n { {#1} } }
	\cs_new:Nn \prot_tl_from_seq:N { \seq_map_function:NN #1 \@@_exp_not_braced:n }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\prot_tl_if_alphabetic:nTF}
%    \begin{macrocode}
	\regex_const:Nn \c@@_alph_regex { \A[A-Za-z]*\Z }
	\cs_new_nopar:Npn \prot_tl_if_alphabetic:nTF { \regex_match:NnTF \c@@_alph_regex }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\prot_provide:Ncn, \prot_provide:Nc}
%    \begin{macrocode}
	\cs_new_protected:Npn \prot_provide:Ncn #1#2#3 { \cs_if_exist:cF {#2} { #1 {#2} {#3} } }
	\cs_new_protected:Npn \prot_provide:Nc #1#2 { \cs_if_exist:cF {#2} { #1 {#2} } }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\prot_tl_replace_kv:nnnn}
%   Ersetze in |#1| die Schlüssel von |#2| und |#3| durch ihre jeweiligen Werte.
%   Bei den Schlüssel-Werte-Paaren aus |#2| nur einmal, bei denen aus |#3| überall.
%   Ergänze wertlose/alleinstehende Schlüssel unmittelbar vor Vorkommen von | ~ \prot_paren:n | in |#1|.
%   Arbeite alles von links nach rechts ab.
%   Ein |\ | im Schlüssel wird wie | | interpretiert.
%   Dies ist insbesondere notwendig, da | | als Schlüsselname leider illegal ist.
%    \begin{macrocode}
	\cs_new_protected:Nn \prot_tl_replace_kv:nnnn {
		\tl_set:Nn \l_tmpa_tl {#1}
		\keyval_parse:nnn { \@@_use_i_ii_iiiplusii:nnn { \tl_replace_once:Nnn \l_tmpa_tl } { ~ \prot_paren:n } } { \@@_tl_replace_aux:NNnn \tl_replace_once:Nnn \l_tmpa_tl } {#2}
		\keyval_parse:nnn { \@@_use_i_ii_iiiplusii:nnn { \tl_replace_all:Nnn  \l_tmpa_tl } { ~ \prot_paren:n } } { \@@_tl_replace_aux:NNnn \tl_replace_all:Nnn  \l_tmpa_tl } {#3}
		\bool_if:nT {#4} { \tl_replace_all:Nnn \l_tmpa_tl { ~ } { \nicehyphen } \tl_replace_all:Nnn \l_tmpa_tl { \xspace } { \nicehyphen } }
		\prot_echo:V \l_tmpa_tl
	}
	\cs_new:Nn \@@_use_i_ii_iiiplusii:nnn { #1 {#2} { #3 #2 } }
	\cs_new:Nn \@@_tl_replace_aux:NNnn {
		\tl_set:Nn \l_tmpb_tl {#3}
		\tl_replace_all:Nnn \l_tmpb_tl { \  } { ~ }
		\exp_args:NNV #1 #2 \l_tmpb_tl {#4}
	}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@, \nicehyphen}
%    \begin{macrocode}
	\cs_new_eq:NN \@@_@ \@
	\cs_set_nopar:Npn \@ { \texorpdfstring { \@@_@ } { } }
	\cs_new_nopar:Npn \nicehyphen { \nobreak-\nobreak\hskip\z@skip }
	\cs_new_nopar:Npn \softhyphen { \nobreak\-\nobreak\hskip\z@skip }
	\cs_new_nopar:Npn \nbsp { \nobreak\  }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\prot_echo:n}
%    \begin{macrocode}
	\cs_set_eq:NN \prot_echo:n \use:n
	\cs_generate_variant:Nn \prot_echo:n { V }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\prot_tl_use:nn, \prot_tl_use:nnnn, \prot_tl_use_german:n}
%    \begin{macrocode}
	\cs_new:Nn \prot_tl_use:nn {
		\tl_head:n {#1} \exp_args:Ne \tl_map_tokens:nn { \tl_tail:n {#1} } { \use:nn {#2} }
	}
	\cs_generate_variant:Nn \prot_tl_use:nn { e }
	\scan_new:N \s@@_tl_mark
	\scan_new:N \s@@_tl_stop
	\cs_new:Npn \@@_use_none_delimit_by_s_tl_stop:w #1 \s@@_tl_stop { }
	\cs_new:Nn \prot_tl_use:nnnn {
		\int_case:nnF { \tl_count:n {#1} } {
			{ 0 } { }
			{ 1 } { \@@_tl_use:nnn #1 { } { } }
			{ 2 } { \@@_tl_use:nnn #1 {#2} }
		} {
			\@@_tl_use:nwnn #1 \s@@_tl_stop
			\s@@_tl_mark
			{#3} {#4}
		}
	}
	\cs_new:Nn \@@_tl_use:nnn { \exp_not:n { #1 #3 #2 } }
	\cs_new:Npn \@@_tl_use:nwnn #1#2 \s@@_tl_mark { \@@_tl_use:nnwnnn #2 \s@@_tl_mark {#1} }
	\cs_new:Npn \@@_tl_use:nnwnnn #1#2#3 \s@@_tl_mark #4 #5 #6 {
		\@@_use_none_delimit_by_s_tl_stop:w #2
		\@@_tl_use_finalone:nwnnn { #4 #6 #1 } \s@@_tl_stop
		\@@_tl_use:nnwnnn {#2} #3 \s@@_tl_mark { #4 #5 #1 } {#5} {#6}
	}
	\cs_new:Npn \@@_tl_use_finalone:nwnnn #1#2 \s@@_tl_mark #3 #4 #5 { \exp_not:n {#1} }
	\cs_new_nopar:Nn \prot_tl_use_german:n { \prot_tl_use:nnnn {#1} { ~und~ } { ,~ } { ~und~ } }
%    \end{macrocode}
% \end{macro}
% Varianten von \LaTeX3-Kernel-Funktionen \cmd\cs_generate_variant:Nn.
%    \begin{macrocode}
	\cs_generate_variant:Nn \tl_range:nnn { nne }
	\cs_generate_variant:Nn \tl_const:Nn { cv }
	\cs_generate_variant:Nn \seq_set_map:NNn { Nc }
	\cs_generate_variant:Nn \seq_set_map_x:NNn { Nc }
	\cs_generate_variant:Nn \msg_error:nnnnn { nnnnV }
	\cs_generate_variant:Nn \str_compare:nNnTF { VNV }
%    \end{macrocode}
% \section{Fehlermeldungen}
%    \begin{macrocode}
	\msg_new:nnnn { prot } { parse / date / wrong } { Das~Eingabeformat~des~Datums~'#1'~ist~falsch. } { Unterstützte~Eingabeformate~sind~2022-01-31,~31.1.2022,~31.01.2022~sowie~2022-1-31. }
	\msg_new:nnnn { prot } { meeting / date / missing } { Kein~Sitzungsdatum~angegeben. } { Gib~bitte~"datum=2022-01-31"~oder~dergleichen~als~Paketoption~oder~in~\exp_not:N\sitzungsdaten~an. }
	\msg_new:nnnn { prot } { persontable / col-count } { Die~Personentabellenzeile~'#1'~enthaelt~#2~statt~6~Spalten. } { In~jeder~Spalte~muessen~genau~5~\&-Zeichen~stehen. }
	\msg_new:nnnn { prot } { person / no-leader } { Es~gibt~keine~Sitzungsleitung. } { In~der~Personentabelle~muss~eine~Sitzungsleitung~eingetragen~werden. }
	\msg_new:nnnn { prot } { person / no-record } { Es~gibt~keine~Protokollfuehrung. } { In~der~Personentabelle~muss~eine~Protkollfuehrung~eingetragen~werden. }
	\msg_new:nnnn { prot } { person / malformed-id } { Die~ID~'#1'~ist~boese. } { Ids~duerfen~nur~die~Buchstaben~A-Z~und~a-z~enthalten.~Keine~Umlaute~oder~sonstigen~Schnickschnack. }
	\msg_new:nnn  { prot } { person / id-exists } { Die~ID~'#1'~ist~bereits~an~jemand~anderen~vergeben. }
	\msg_new:nnn  { prot } { person / id-iscsname } { Die~ID~'#1'~existiert~bereits~als~LaTeX-Makro. }
	\msg_new:nnnn { prot } { person / name-exists } { Der~Name~'#1'~fuer~'#2'~ist~bereits~an~'#3'~vergeben. } { Dies~koennte~Teile~der~Bevoelkerung~verwirren. }
	\msg_new:nnnn { prot } { move / wrong-groupvoter } { Interne~Warnung:~'#1'~bewegt~sich~illegal. } { Dies~sollte~beim~zweiten~Kompilieren~nicht~mehr~vorkommen. }
	\msg_new:nnnn { prot } { move / not-there } { '#1'~bewegt~sich,~war~aber~gar~nicht~auf~der~Sitzung. } { Vielleicht~war~sie~doch~anwesend? }
	\msg_new:nnnn { prot } { move / 0-again } { '#1'~geht~zwei~mal~hintereinander. } { Vielleicht~kam~sie~zwischendrin~wieder? }
	\msg_new:nnnn { prot } { move / 1-again } { '#1'~kommt~zwei~mal~hintereinander. } { Vielleicht~ging~sie~zwischendrin~wieder? }
	\msg_new:nnnn { prot } { voting / wrong-count } { Von~#3~anwesenden~Stimmberechtigten~haben~#1=#2~abgestimmt. } { Falls~das~so~richtig~ist,~nutze~die~\exp_not:N\Erg-Funktion. }
	\msg_new:nnnn { prot } { voting / super-stars } { Das~Abstimmungsergebnis~'#1'~enthaelt~zu~viele~Sterne. } { Es~kann~nur~einen~*S*t*a*r*~geben. }
%    \end{macrocode}
% \section{And the end}
%    \begin{macrocode}
	\UseHook { prot / after }
%</package>
%    \end{macrocode}
%
% \Finale
\endinput
% vim: sw=4 ts=4 noet fdm=marker foldmarker=\\begin,\\end foldcolumn=3
